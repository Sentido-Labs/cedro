<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>C programming language extension: Cedro pre-processor</title>
    <style type="text/css">@font-face { font-family: 'sorts_mill_goudyregular'; src: local('OFL Sorts Mill Goudy TT'), url('doc/fonts/GoudyStM-webfont.woff') format('woff'); font-weight: normal; font-style: normal; } /* WebKit-specific: */ :root { color-scheme: light dark; } html { background:#111; } body { margin:0; } section:first-child { margin-top:0; } section, footer { font-family:sans-serif; line-height:1.5; max-width:82em; margin:0.5em auto 0.5em auto; background:#222; color:#c92; text-shadow:0 0.1em 0.1em #000; border:thin solid #222; padding:1em; } section + section, section + footer { margin-top:2em; } section>h2:first-child { margin-top:0; } p,ul,table { } a, a:visited { color:#99e; text-decoration:none; box-shadow:0 2px 1px -1px #77e; } a.img { box-shadow:none; } a.img > img { vertical-align:bottom; } a>code { border-bottom:none; background-color:transparent; } code>a { color:inherit !important; } code>b { background:#000; } url, code, tt { display:inline; vertical-align:baseline; padding:0; font-family:'Input', 'Fira Code', 'monospace'; white-space:pre-wrap; } url { color:#ccc; } url:before, url:after { content:'"'; color:#777; } td > url, td > code.command-line-option { display:block; text-align:right; } td > code.command-line-option { font-style:italic; background:transparent; border:none; padding:0; } code { background:#111; color:#8d8; border:thin solid #333; border-radius:0.25em; padding:0.25em; } section > code, td > code { display:inline-block; vertical-align:baseline; overflow-wrap:anywhere; word-break:break-all; } h1 { font-size:200%; margin:0; background-color:#070707; color:#eee; font-family:sorts_mill_goudyregular, serif; font-weight:normal; } h1::after { clear:both; content:""; display:block; } h1>img { vertical-align:bottom; } h2 { font-size:128%; } h3 { font-size:116%; } h4 { font-size:110%; } h2, h3, h4 { font-family:sans-serif; font-weight:normal; color:#c72; border-left:0.75rem solid rgba(204,119,34,0.25); margin-left:-1rem; margin-right:-0.25rem; padding-left:0.25rem; padding-right:0.25rem; } h1>a.anchor, h2>a.anchor, h3>a.anchor, h4>a.anchor { visibility:hidden; } h1:hover>a.anchor, h2:hover>a.anchor, h3:hover>a.anchor, h4:hover>a.anchor { visibility:visible; } table { border-collapse:collapse; background:inherit; } th, td { vertical-align:top; border:thin solid #777; padding:0.5em; } th:empty, td:empty { border:none; } th { font-weight:normal; } p,ul,blockquote { max-width:50em; text-align:justify; } blockquote { border-left:thin solid; padding-left:0.5em; font-style:italic; margin-left:3em; max-width:45em; } blockquote>address { text-align:right; } blockquote>address::before { content:"— "; } .language-selector { padding:0.25rem; font-size:1rem; } .link-to-table-of-contents { background:#111; padding:0.25em; position:fixed; bottom:0; right:0; } @media (prefers-color-scheme:light) { html { background:#ddd; } section, footer { background:#eee; color:#111; text-shadow:none; border-color:#ccc; } a, a:visited { color:#11d; box-shadow:0 2px 1px -1px #ccd; } h1 a, h1 a:visited { color:#ccf; } code { background:#f7f7f7; color:#000; border-color:#eee; } code>b { background:#fff; } url { color:#444; } url:before, url:after { color:#999; } h2, h3, h4 { color:#222; border-color: rgba(34,34,34,0.15); } .link-to-table-of-contents { background:#ddd; } } [title]::after { content:" †"; font-size:75%; vertical-align:top; } table.benchmark td { text-align:right; font-family:monospace; font-family:'Input', 'Fira Code', 'monospace'; }</style>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
  </head>
  <body>
    <section>
      <h1 style="text-align:center"><span style="float:left"><a href="https://sentido-labs.com/en/library/?filter=cedro" class="img"><img alt="Atlas blue cedar" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABABAMAAABYR2ztAAAAGFBMVEUAAAAWLxcoYCg5izpCsUNN1U1b9Fp7+3umzZ3RAAAAI2lUWHRBdXRob3IAAAAAAEFsYmVydG8gR29uesOhbGV6IFBhbG9tb8X116oAAAGpSURBVEjH5ZTBdpswEEWBnO4dO+dkawTZxwjsbQwjs66R4ANAow+Ipfn9qq7betUgs+xbcpir0byniaL/UElerOIF9Vl7ORBdinT1IOCVyEnVnJDMxyP1cYudR5D5HJqetuGAjW//oITSveqJ7DGc8G3aGzKOJTUTvcQpGJBmMOgz32Rc9NYgjkWgJS9y6CcFNedZCQorZagMMuRJK9e09vycsRzKhhUlSqyDCKsorXo0NEDBSgWclzCF2ZGsr//nOxZF6zROTuMxMAo+Bxr7UQiUSnLgVbMPCNXGJ9kaPRApIkLddnv8WMXn+beIcwCyvg3jENFYdD+jiUg8ZBLJUUjv4vTmnFGocRLaeBDtnmeboRSisjw/thYt+kghoK3M5+weXK+0kg2HZhvDwXo3kMhcqnHeHGIx+TP1SSifpvco/n7LaXdKZzbQErqxY+uMcYB8+8hqaN0twQlIqB9aLn/OLQXA+6JN+6SlhNUiBICQ3SJEpfwoFt3jTYFHdEE1/F5VzXabOmXw99PXBLw+qN/y2/qa6V/y7wu/JtCdbixyd4wZPfxb+geh0KANiaQN5QAAAABJRU5ErkJggg==" width="64" height="64"/></a> Cedro</span>
        <span class="language-selector"><a href="README.es.html">Español</a>, English</span>
        <a style="display:inline-block;float:right;font-size:1rem;padding:0.5em" href="http://sentido-labs.com" class="img"><img alt="Sentido-Labs.com" src="doc/sentido-labs-mono.svg" style="width:5em" width="157" height="33"/></a>
      </h1>
      <p style="clear:both"><em>Cedro</em> is a C language extension that works as a pre-processor with seven features:</p>
      <ol>
        <li>The <a href="#backstitch-macro"><em>backstitch</em> <code>@</code> macro</a> (<a href="#backstitch-macro-related-work">related work</a>).</li>
        <li><a href="#deferred-resource-release"><em>Deferred</em> resource release <code>auto ...</code></a> or <code>defer ...</code> (<a href="#deferred-resource-release-related-work">related work</a>).</li>
        <li><a href="#label-break">Break out of <em>nested loops</em> <code>break <em>label</em>;</code></a> (<a href="#label-break-">related work</a>).</li>
        <li><a href="#slice-notation">Notation for array <em>slices</em> <code>array[start..end]</code></a> (<a href="#slice-notation-related-work">related work</a>).</li>
        <li><a href="#block-macros"><em>Block</em> macros <code>#define { ... #define }</code></a><!-- (<a href="#block-macros-related-work">related work</a>)-->.</li>
        <li><a href="#loop-macros"><em>Loop</em> macros <code>#foreach { ... #foreach }</code></a><!-- (<a href="#loop-macros-related-work">related work</a>)-->.</li>
        <li><a href="#binary-include"><em>Binary</em> inclusion <code>#include {...}</code>/<code>#embed "..."</code></a> (<a href="#binary-include-related-work">related work</a>).</li>
      </ol>
      <p>To activate it, the source file must contain this line:
        <code>#pragma Cedro 1.0</code><br/>
        Otherwise, the file is copied directly to the output.</p>
      <p>This line can contain certain options, for instance
        <code>#pragma Cedro 1.0 defer,#embed</code>
        to activate the use of
        <a href="#deferred-resource-release"><code>defer</code> instead of <code>auto</code></a>
        and of
        <a href="#binary-include"><code>#embed "…"</code> instead of <code>#include {…}</code></a>.</p>
      <p>The <b>source code</b> (<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a> license) can be found at <a href="https://sentido-labs.com/es/biblioteca/?filter=cedro">the library</a>.<br/><code>cedro</code> only uses the standard C functions, <code>cedrocc</code> and <code>cedro-new</code> require <a href="https://es.wikipedia.org/wiki/POSIX">POSIX</a>.</p>

      <code>Usage: cedro [options] &lt;file.c&gt;…
       cedro new &lt;name&gt; # Runs: <a href="#cedro-new">cedro-new</a> &lt;name&gt;
  To read from stdin, put - instead of &lt;file.c&gt;.
  The result goes to stdout, can be compiled without intermediate file:
 cedro file.c | cc -x c - -o file
  It is what the <a href="#cedrocc">cedrocc</a> program does:
 cedrocc -o file file.c
  With cedrocc, the following options are the defaults:
    --insert-line-directives
  Code gets modified only after the line `#pragma Cedro 1.0`,
 which can include certain options: `#pragma Cedro 1.0 defer,#embed`

  --apply-macros     Applies the macros: backstitch, defer, etc. (default)
  --no-apply-macros  Does not apply the macros.
  --escape-ucn       Escape non-ASCII in identifiers as UCN.
  --no-escape-ucn    Does not escape non-ASCII in identifiers. (default)
  --discard-comments    Discards the comments.
  --discard-space       Discards all whitespace.
  --no-discard-comments Does not discard comments.   (default)
  --no-discard-space    Does not discard whitespace. (default)
  --insert-line-directives    Insert `#line` directives.
  --no-insert-line-directives Does not insert `#line` directives. (default)
  --embed-directive     Enables the `#embed` directive.
                        Same as `#pragma Cedro 1.0 #embed`.
  --no-embed-directive  Disables the `#embed` directive. (default)
  --embed-as-string=&lt;limit&gt; Use string literals instead of bytes
                            for files smaller than &lt;limit&gt;.
                            Default value: 0
  --defer-instead-of-auto    Use the keyword `defer` instead of `auto`.
                             Same as `#pragma Cedro 1.0 defer`.
  --no-defer-instead-of-auto Use the keyword `auto`. (default)

  --print-markers    Prints the markers.
  --no-print-markers Does not print the markers. (default)
  --benchmark        Run a performance benchmark.
  --validate=ref.c   Compares the input to the given “ref.c” file.
      Does not apply any macros: to compare the result of running Cedro
      on a file, pipe its output through this option, for instance:
      `cedro file.c | cedro - --validate=ref.c`
  --version          Show version: 1.0
                     The corresponding “pragma” is: `#pragma Cedro 1.0`</code>
      <p>The option <code>--escape-ucn</code> encodes Unicode® characters
        outside of the ASCII range, when they appear as part of an identifier,
        as C99 universal character names
        (“C99 standard”, page 65, “<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf#65">6.4.3 Universal character names</a>”),
        which can be useful for older compilers without UTF-8 support such as
        <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67224#c32">GCC before version 10</a>.</p>
      <p>For API documentation, see <url><a href="doc/api/index.html">doc/api/index.html</a></url>
        after running <code>make doc</code> that requires having
        <a href="https://www.doxygen.nl/index.html">Doxygen</a> installed.</p>

      <h2><code id="cedrocc">cedrocc</code> <a class="anchor" href="#cedrocc">#cedrocc</a></h2>
      <p>The second executable, <code>cedrocc</code>, allows using Cedro as if it was part of the C compiler.</p>
      <code>Usage: cedrocc [options] &lt;file.c&gt; [&lt;file2.o&gt;…]
  Runs Cedro on the first file name that ends with “.c”,
 and compiles the result with “cc -x c - -x none” plus the other arguments.
    cedrocc -o file file.c
    cedro file.c | cc -x c - -o file
  The options get passed as is to the compiler, except for those that
 start with “--cedro:…” that correspond to cedro options,
 for instance “--cedro:escape-ucn” is like “cedro --escape-ucn”.
  The following option is the default:
    --cedro:insert-line-directives
  In addition, for each `#include`, if it finds the file it reads it and
 if it finds `#pragma Cedro 1.0` processes it and inserts the result
 in place of the `#include`.
  You can specify the compiler, e.g. `gcc`:
    CEDRO_CC='gcc -x c - -x none' cedrocc …
  For debugging, this writes the code that would be piped into `cc`,
 into `stdout` instead:
    CEDRO_CC='' cedrocc …</code>
      <p>If you get an error message like “embedding a directive within macro arguments is not portable” (GCC) or “embedding a directive within macro arguments has undefined behavior” (clang), it means that you’re using Cedro with <code>--insert-line-directives</code> inside the parameters for a macro. You can either expand the code given to the macro manually, or avoid <code>--insert-line-directives</code> by replacing <code>cedrocc -o file file.c</code> with <code>cedro file.c | cc -x c - -o file</code>.</p>
      <p><code>cedrocc</code> does another thing in addition to <code>cedro file.c | cc -x c - -o file</code>:
        for each <code>#include</code>, if it finds the file (<code>-I ...</code>) it looks inside for <code>#pragma Cedro 1.0</code> and if found, processes the file and inserts the result in place of the <code>#include</code>. The reason is being able to compile in one go programs that use Cedro in several files, instead of having to transform each of them into temporary files to be compiled later.</p>

      <h2 id="cedro-new"><code>cedro-new</code> <a class="anchor" href="#cedro-new">#cedro-new</a></h2>
      <p>There is a third executable, <code>cedro-new</code>, that produces a program draft in a similar way to <code>cargo new</code> in Rust. <code>cedro new …</code> will actually run <code>cedro-new …</code>. The content is produced from the template in the <url>template/</url> directory, that gets included in the <code>cedro-new</code> executable at compilation.</p>
      <code>Usage: cedro-new [options] &lt;name&gt;
  Creates a directory named &lt;name&gt;/ with the template.
  -h, --help        Shows this message.
  -i, --interactive Asks for the names for command and project.
                    Otherwise, they will be derived from the directory name.</code>

      <p>When producing the draft, certain patterns get replaced in
        <url>Makefile</url>, <url>README.md</url>, and all the files
        under <url>src/</url>:</p>
      <ul>
        <li><code>{#year}</code>: the current year.</li>
        <li><code>{#Author}</code>: name and email address
          reported by
          <code>git config user.name</code> and <code>… user.email</code>
          if they are available, and if not
          “Your Name Here &lt;email@example.com&gt;”.</li>
        <li><code>{#Template}</code>: the project name,
          e.g. “Cedro”.</li>
        <li><code>{#template}</code>: the program name,
          e.g. “cedro”.</li>
      </ul>

      <p>The template includes several project drafts, that can be activated in the generated <url>Makefile</url>:</p>
      <ul>
        <li><p>Command line (“CLI”) tool
            that identifies the type of each argument,
            and uses a <code>btree</code>
            to count how many times each one is repeated.
            This gets built if the <url>Makefile</url> is not modified.</p></li>
        <li><p>Graphical application with <em><a href="https://github.com/memononen/nanovg">nanovg</a></em>.
            Downloads (with <code>curl</code>) and
            compiles automatically nanovg, <a href="https://www.glfw.org/">GLFW</a>, and <a href="https://github.com/nigels-com/glew">GLEW</a>.</p>
          <code style="display:inline-block;vertical-align:top">include Makefile.nanovg.mk
MAIN=src/main.nanovg.c</code></li>
        <li><p>HTTP/1.1 server using <em><a href="https://libuv.org/">libuv</a></em>.
            Downloads (with <code>curl</code>) and
            compiles automatically libuv.</p>
          <code style="display:inline-block;vertical-align:top">include Makefile.libuv.mk
MAIN=src/main.libuv.c</code></li>
      </ul>

    </section>

    <section id="backstitch-macro">
      <h2><a href="https://en.wikipedia.org/wiki/Backstitch">Backstitch</a> macro: @ <a class="anchor" href="#backstitch-macro">#backstitch-macro</a></h2>
      <p>Threads a value through a sequence of function calls,
        as first parameter for each of them.</p>
      <p>It is an explicit version of what other programming languages
        do to implement member functions, and the result is a usual pattern
        in C libraries.</p>
      <p>Note: the <code>@</code> symbol is not recognized
        when written as <code>\u0040</code>,
        but it gets converted to <code>@</code> in the output.
        This serves to escape it when chaining Cedro with another
        pre-processor that uses it.</p>
      <table>
        <tr>
          <td><code>object @ f(a), g(b);</code></td>
          <td><code>f(object, a);
g(object, b);</code></td>
        </tr>
        <tr>
          <td><code>&amp;object @ f(a), g(b);</code></td>
          <td><code>f(&amp;object, a);
g(&amp;object, b);</code></td>
        </tr>
        <tr>
          <td><code>object.field @ f(a), g(b);</code></td>
          <td><code>f(object.field, a);
g(object.field, b);</code></td>
        </tr>
        <tr>
          <td><code>int x = (object @ f(a), g(b));</code></td>
          <td><code>int x = (f(object, a), g(object, b));</code>
            <p>This is the C <a href="https://en.wikipedia.org/wiki/Comma_operator">comma operator</a>, it’s the same as</p>
            <code>f(object, a); int x = g(object, b);</code></td>
        </tr>
        <tr>
          <td><code>object @prefix_... f(a), g(b);</code></td>
          <td><code>prefix_f(object, a);
prefix_g(object, b);</code></td>
        </tr>
        <tr>
          <td><code>object @..._suffix f(a), g(b);</code></td>
          <td><code>f_suffix(object, a);
g_suffix(object, b);</code></td>
        </tr>
        <tr>
          <td>
<code>graphics_context @<a href="https://github.com/memononen/nanovg">nvg</a>...
    BeginPath(),
    Rect(100,100, 120,30),
    Circle(120,120, 5),
    PathWinding(NVG_HOLE),
    FillColor(nvgRGBA(255,192,0,255)),
    Fill();</code>
          </td><td>
<br/><code>nvgBeginPath(graphics_context);
nvgRect(graphics_context, 100,100, 120,30);
nvgCircle(graphics_context, 120,120, 5);
nvgPathWinding(graphics_context, NVG_HOLE);
nvgFillColor(graphics_context, nvgRGBA(255,192,0,255));
nvgFill(graphics_context);</code>
          </td>
        </tr>
      </table>

      <p>For each comma-separated segment,
      if it starts with any of the tokens
      <code>[</code>,
      <code>++</code>, <code>--</code>, <code>.</code>, <code>-></code>,
      <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code>,
      or there is nothing that looks like a function call,
      the insertion point is the beginning of the segment:</p>

      <table>
        <tr>
          <td><code>number_array @ [3]=44, [2]=11;</code></td>
          <td><code>number_array[3]=44; number_array[2]=11;</code></td>
        </tr>
        <tr>
          <td><code>*number_array++ @ = 1, = 2;</code></td>
          <td><code>*number_array++ = 1; *number_array++ = 2;</code></td>
        </tr>
        <tr>
          <td><code>figure_center_point @ .x=44, .y=11;</code></td>
          <td><code>figure_center_point.x=44; figure_center_point.y=11;</code></td>
        </tr>
      </table>

      <p>Complex expressions can be used as prefixes by putting them
        to the left of the <code>@</code> and leaving the ellipsis
        without prefix or suffix:</p>
      <table>
        <tr>
          <td><code>// <a href="https://github.com/rryqszq4/ngx_sqlite/blob/785dbf1485bf347c260fa540c4d0955d4d079901/src/ngx_http_sqlite_module.c#L802">ngx_http_sqlite_module.c#L802</a>

(*chain->last)->buf->@ ...
    pos = u_str,
    last = u_str + ns.len,
    memory = 1;</code></td>
          <td><br/><code>// <a href="https://github.com/rryqszq4/ngx_sqlite/blob/785dbf1485bf347c260fa540c4d0955d4d079901/src/ngx_http_sqlite_module.c#L802">ngx_http_sqlite_module.c#L802</a>

(*chain->last)->buf->pos = u_str;
(*chain->last)->buf->last = u_str + ns.len;
(*chain->last)->buf->memory = 1;</code></td>
        </tr>
      </table>

      <p>The object part can be left empty, which is useful for things like
        adding prefixes or suffixes to enumerations:</p>

      <table>
        <tr>
          <td>
<code>typedef enum {
    @TOKEN_... SPACE, WORD, NUMBER
} TokenType;</code>
          </td>
          <td>
<code>typedef enum {
    TOKEN_SPACE, TOKEN_WORD, TOKEN_NUMBER
} TokenType;</code>
          </td>
        </tr>
        <tr>
          <td><code>// <a href="http://docs.libuv.org/en/v1.x/guide/threads.html#core-thread-operations">http://docs.libuv.org/en/v1.x/guide/threads.html#core-thread-operations</a>
// `hare` and `tortoise` are functions.
int main() {
    int tracklen = 10;
    @uv_thread_...
        t hare_id,
        t tortoise_id,
        create(&amp;hare_id, hare, &amp;tracklen),
        create(&amp;tortoise_id, tortoise, &amp;tracklen),

        join(&amp;hare_id),
        join(&amp;tortoise_id);
    return 0;
}
</code></td>
          <td><br/><code>// <a href="http://docs.libuv.org/en/v1.x/guide/threads.html#core-thread-operations">http://docs.libuv.org/en/v1.x/guide/threads.html#core-thread-operations</a>
// `hare` and `tortoise` are functions.
int main() {
    int tracklen = 10;
    uv_thread_t hare_id;
    uv_thread_t tortoise_id;
    uv_thread_create(&amp;hare_id, hare, &amp;tracklen);
    uv_thread_create(&amp;tortoise_id, tortoise, &amp;tracklen);

    uv_thread_join(&amp;hare_id);
    uv_thread_join(&amp;tortoise_id);
    return 0;
}
</code></td>
        </tr>
        <tr>
          <td><code>function(a, @prefix_... b, c)</code></td>
          <td><code>function(a, prefix_b, prefix_c)</code></td>
        </tr>
      </table>

      <p>The segments part can also be left empty
        to add either a prefix or a suffix to an identifier:</p>
      <table>
        <tr>
          <td><code>Next(reader) @xmlTextReader...;</code></td>
          <td><code>xmlTextReaderNext(reader);</code></td>
        </tr>
        <tr>
          <td><code>get(&amp;vector, index) @..._Byte_vec;</code></td>
          <td><code>get_Byte_vec(&amp;vector, index);</code></td>
        </tr>
        <tr>
          <td><code>function(a, b @prefix_..., c)</code></td>
          <td><code>function(a, prefix_b, c)</code></td>
        </tr>
      </table>

      <p>It is a left-associative operator:</p>

      <table>
        <tr>
          <td><code>object @ f(a) @ g(b);</code></td>
          <td><code>g(f(object, a), b);</code></td>
        </tr>
        <tr>
          <td><code>x @ one() @ two() @ three() @ four();</code></td>
          <td><code>four(three(two(one(x))));</code></td>
        </tr>
      </table>

      <h3 id="backstitch-macro-related-work">Related work <a class="anchor" href="#backstitch-macro-related-work">#…-related-work</a></h3>
      <p>Looking for prior implementations of this idea I’ve found
        <a href="https://github.com/eudoxia0/magma">magma</a> (2014),
        where it is called
        <code><a href="https://github.com/eudoxia0/magma#doto">doto</a></code>.
        It is a macro for the
        <a href="https://github.com/eudoxia0/cmacro">cmacro</a>
        pre-processor which has the inconvenient of needing the Common Lisp
        <a href="http://www.sbcl.org/">SBCL</a> compiler
        in addition to the C compiler.</p>
      <p>Clojure also has a macro called <code>doto</code> which works
        in a similar manner,
        for instance to do <code>f₁(x); f₂(x); f₃(x);</code>:</p>
      <table>
        <tr><th><a href="https://github.com/eudoxia0/magma">Magma</a></th><td><code>doto</code></td><td><em><a href="https://github.com/eudoxia0/magma#doto">doto</a></em> macro</td><td><code>doto(x) { f₁(); f₂(); f₃(); }</code></td></tr>
        <tr><th><a href="https://clojure.org/guides/threading_macros">Clojure</a></th><td><code>doto</code></td><td><em><a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/doto">doto</a></em> macro</td><td><code>(doto x f₁ f₂ f₃)</code></td></tr>
        <tr><th><a href="#">Cedro</a></th><td><code>@</code></td><td><em><a href="#backstitch-macro">backstitch</a></em> macro</td><td><code>x @ f₁(), f₂(), f₃()</code></td></tr>
      </table>
      <p>Functional languages often have a similar operator
        without the ability to thread a same value
        through several functions.
        For instance, the equivalent of <code>f₃(f₂(f₁(x)))</code>:</p>
      <table>
        <tr><th><a href="https://en.wikipedia.org/wiki/Thompson_shell">Shell</a></th><td><code>|</code></td><td><em><a href="http://doc.cat-v.org/unix/pipes/">pipe</a></em> operator</td><td><code>echo x | f₁ | f₂ | f₃</code></td></tr>
        <tr><th><a href="https://www.haskell.org/">Haskell</a></th><td><code>&</code></td><td><em><a href="https://downloads.haskell.org/~ghc/9.2.1/docs/html/libraries/base-4.16.0.0/Data-Function.html#v:-38-">reverse application</a></em> operator</td><td><code>x & f₁ & f₂ & f₃</code></td></tr>
        <tr><th><a href="https://elixir-lang.org/">Elixir</a></th><td><code>|&gt;</code></td><td><em><a href="https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2">pipe</a></em> operator</td><td><code>x |&gt; f₁ |&gt; f₂ |&gt; f₃</code></td></tr>
        <tr><th><a href="https://clojure.org/guides/threading_macros">Clojure</a></th><td><code>-&gt;</code></td><td><em><a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-%3E">threading</a></em> macro</td><td><code>(-&gt; x f₁ f₂ f₃)</code></td></tr>
        <tr><th><a href="#">Cedro</a></th><td><code>@</code></td><td><em><a href="#backstitch-macro">backstitch</a></em> macro</td><td><code>x @ f₁() @ f₂() @ f₃()</code></td></tr>
      </table>
      <p>Ada 2005 introduced a feature called
        <a href="https://www.adaic.org/resources/add_content/standards/05rat/html/Rat-2-3.html">prefixed-view notation</a>
        that is more similar to C++
        as the exact function being called can not be determined without
        knowing which methods are implemented for the object type.</p>
    </section>

    <section id="deferred-resource-release">
      <h2>Deferred resource release: <a class="anchor" href="#deferred-resource-release">#deferred-resource-release</a></h2>
      <p>Moves the clean-up code for a variable to the end of its scope
        including the exit points
        <code>break</code>, <code>continue</code>, <code>goto</code>,
        <code>return</code>.</p>
      <p>In C, resources must be released back to the system explicitly
        once they are no longer needed, which usualy happens quite far
        from the place where they were allocated.
        As time passes and changes accumulate in the program,
        it’s easy to forget releasing them in all cases
        or to attempt releasing a resource twice.</p>
      <p>Other programming languages have mechanisms for automatic
        resource release:
        C++ for instance, uses functions called <em>destructors</em>
        that get run <strong>implicitly</strong>
        when exiting a variable’s scope.</p>
      <p>The programming language Go introduced an <strong>explicit</strong> notation called
        “<a href="https://blog.golang.org/defer-panic-and-recover"><em>defer</em></a>”
        that fits better the style of C.
        The first difference is that in Go,
        all releases happen when exiting the function,
        while with Cedro the releases happen when exiting each block,
        like the destructors in C++ do.</p>
      <p>There are more differences, such as for instance that in Go it
        can be used to modify the return value of the function,
        and that Cedro does not even try to handle
        <code><a href="https://en.cppreference.com/w/c/program/longjmp">longjmp()</a></code>,
        <code><a href="https://en.cppreference.com/w/c/program/exit">exit()</a></code>,
        <code><a href="https://en.cppreference.com/w/c/thread/thrd_exit">thrd_exit()</a></code> etc.
        because it could only apply the deferred actions in the current function, not in any function that called this one. See “<i><a href="https://gustedt.wordpress.com/2020/12/14/a-defer-mechanism-for-c/">A defer mechanism for C</a></i>” (<a href="https://hal.inria.fr/hal-03090771/document">published academic paper as PDF</a> in the <a href="http://www.sigapp.org/sac/sac2021/program.html">SAC’21</a> conference) for a compiler-level implementation that does handle <code>longjmp()</code> and stack unwinding.</p>
      <p>In Cedro, the release function is marked with the
      <a href="https://en.cppreference.com/w/c/language/storage_duration">C keyword <b><code>auto</code></b></a>
      which is not needed in standard C code
      <em>before C23</em>
      because it is the default and can be replaced with <code>signed</code> as
      <a href="https://stackoverflow.com/a/60890064/291462">it has the same effect</a>.</p>
      <p>It is also possible to use <code>defer</code> instead of <code>auto</code>
        with the option <code>--defer-instead-of-auto</code>,
        or adding the keyword “defer” to the “pragma”:
        <code>#pragma Cedro 1.0 <b>defer</b></code>.</p>
      <table>
        <tr>
          <td>
<code><b>#pragma Cedro 1.0</b>
…
    char* text = malloc(count + 1);
    if (!text) return ENOMEM;
    <b>auto free(text);</b>
…
    if (file_name) {
        FILE* file = fopen(file_name, "w");
        if (!file) return errno;
        <b>auto fclose(file);</b>
        fwrite(text, sizeof(char), count, file);
…</code></td>
          <td>
<code><b>#pragma Cedro 1.0 defer</b>
…
    char* text = malloc(count + 1);
    if (!text) return ENOMEM;
    <b>defer free(text);</b>
…
    if (file_name) {
        FILE* file = fopen(file_name, "w");
        if (!file) return errno;
        <b>defer fclose(file);</b>
        fwrite(text, sizeof(char), count, file);
…</code></td>
        </tr>
      </table>
      <p>In this example, there is a <code>text</code> store and a <code>file</code> that must be released back to the system:</p>
      <table>
        <tr>
          <td>
<code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;

<b>#pragma Cedro 1.0</b>

int repeat_letter(char letter, size_t count,
                  char* file_name)
{
    char* text = malloc(count + 1);
    if (!text) return ENOMEM;
    <b>auto free(text);</b>
    for (size_t i = 0; i &lt; count; ++i) {
        text[i] = letter;
    }
    text[count] = 0;
    if (file_name) {
        FILE* file = fopen(file_name, "w");
        if (!file) return errno;
        <b>auto fclose(file);</b>
        fwrite(text, sizeof(char), count, file);
        fputc('\n', file);
    }
    printf("Repeated %lu times: %s\n",
           count, text);
    return 0;
}

int main(void)
{
    return repeat_letter('A', 6, "aaaaaa.txt");
}</code></td><td>
<br/><br/><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;

int repeat_letter(char letter, size_t count,
                  char* file_name)
{
    char* text = malloc(count + 1);
    if (!text) return ENOMEM;
    for (size_t i = 0; i &lt; count; ++i) {
        text[i] = letter;
    }
    text[count] = 0;
    if (file_name) {
        FILE* file = fopen(file_name, "w");
        if (!file) {
            <b>free(text);</b>
            return errno;
        }
        fwrite(text, sizeof(char), count, file);
        fputc('\n', file);
        <b>fclose(file);</b>
    }
    printf("Repeated %lu times: %s\n",
           count, text);
    <b>free(text);</b>
    return 0;
}

int main(void)
{
    return repeat_letter('A', 6, "aaaaaa.txt");
}</code></td>
        </tr>
      </table>

      <p>Compiling it with GCC or clang,
        on the left running explicitly the compiler,
        and on the right using <code>cedrocc</code>:</p>
      <table>
        <tr>
<td><code>$ cedro repeat.c | cc -o repeat -x c -
$ ./repeat
Repeated 6 times: AAAAAA
$ cat aaaaaa.txt
AAAAAA
$ valgrind --leak-check=yes ./repeat
…
==8795== HEAP SUMMARY:
==8795==     in use at exit: 0 bytes in 0 blocks
==8795==   total heap usage: 4 allocs, 4 frees,
                             5,599 bytes allocated
==8795==
==8795== All heap blocks were freed -- no leaks are possible</code>
</td><td>
<code>$ cedrocc -o repeat repeat.c
$ ./repeat
Repeated 6 times: AAAAAA
$ cat aaaaaa.txt
AAAAAA
$ valgrind --leak-check=yes ./repeat
…
==8795== HEAP SUMMARY:
==8795==     in use at exit: 0 bytes in 0 blocks
==8795==   total heap usage: 4 allocs, 4 frees,
                             5,599 bytes allocated
==8795==
==8795== All heap blocks were freed -- no leaks are possible</code>
</td>
        </tr>
      </table>

      <p>In this example adapted from
        <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2542.pdf#40">“Proposal for C2x, WG14 ​n2542, Defer Mechanism for C” p. 40</a>,
        the released resources are spin locks:
        <em>(the difference of course is that in this case the <code>spin_unlock()</code> calls do not run after the panic)</em></p>
      <table>
        <tr>
          <td>
            <code>/* Adapted from example in n2542.pdf#40 */

<b>#pragma Cedro 1.0</b>

int f1(void) {
  puts("g called");
  if (bad1()) { return 1; }
  spin_lock(&amp;lock1);
  <b>auto spin_unlock(&amp;lock1);</b>
  if (bad2()) { return 1; }
  spin_lock(&amp;lock2);
  <b>auto spin_unlock(&amp;lock2);</b>
  if (bad()) { return 1; }

  /* Access data protected by the spinlock then force a panic */
  completed += 1;
  unforced(completed);

  return 0;
}</code>
          </td>
          <td>
            <code>/* Adapted from example in n2542.pdf#40 */

int f1(void) {
  puts("g called");
  if (bad1()) { return 1; }
  spin_lock(&amp;lock1);
  if (bad2()) { <b>spin_unlock(&amp;lock1);</b> return 1; }
  spin_lock(&amp;lock2);
  if (bad()) { <b>spin_unlock(&amp;lock2); spin_unlock(&amp;lock1);</b> return 1; }

  /* Access data protected by the spinlock then force a panic */
  completed += 1;
  unforced(completed);

  <b>spin_unlock(&amp;lock2);</b>
  <b>spin_unlock(&amp;lock1);</b>

  return 0;
}
</code>
          </td>
        </tr>
      </table>

      <p>Andrew Kelley compared resource management between C and his
        <a href="https://ziglang.org/">Zig programming language</a>
        in a 2019 presentation titled
        <a href="https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s">“The Road to Zig 1.0” at 29:21s</a>,
        and here I’ve re-created his C example using Cedro to produce
        the function as he showed it, except that Cedro does not know
        that the final <code>for</code> loop never ends so it adds
        unnecessary resource release code after it.</p>
      <table>
        <tr>
          <td>
            <code>// Example retrofitted from C example by Andrew Kelley:
// <a href="https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s">https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s</a>

<b>#pragma Cedro 1.0</b>

int main(int argc, char **argv) {
    struct SoundIo *soundio = soundio_create();
    if (!soundio) {
        fprintf(stderr, "out of memory\n");
        return 1;
    }
    <b>auto soundio_destroy(soundio);</b>
    int err;
    if ((err = soundio_connect(soundio))) {
        fprintf(stderr, "unable to connect: %s\n", soundio_strerror(err));
        return 1;
    }
    soundio_flush_events(soundio);
    int default_output_index = soundio_default_output_device_index(soundio);
    if (default_output_index < 0) {
        fprintf(stderr, "No output device\n");
        return 1;
    }
    struct SoundIoDevice *device = soundio_get_output_device(soundio, default_output_index);
    if (!device) {
        fprintf(stderr, "out of memory\n");
        return 1;
    }
    <b>auto soundio_device_unref(device);</b>
    struct SoundIoOutStream *outstream = soundio_outstream_create(device);
    if (!outstream) {
        fprintf(stderr, "out of memory\n");
        return 1;
    }
    <b>auto soundio_outstream_destroy(outstream);</b>
    outstream->format = SoundIoFormatFloat32NE;
    outstream->write_callback = write_callback;
    if ((err = soundio_outstream_open(outstream))) {
        fprintf(stderr, "unable to open device: %s" "\n", soundio_strerror(err));
        return 1;
    }
    if ((err = soundio_outstream_start(outstream))) {
        fprintf(stderr, "unable to start device: %s\n", soundio_strerror(err));
        return 1;
    }
    for (;;) soundio_wait_events(soundio);
}</code>
          </td><td>
            <code>// Example retrofitted from C example by Andrew Kelley:
// <a href="https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s">https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s</a>

int main(int argc, char **argv) {
    struct SoundIo *soundio = soundio_create();
    if (!soundio) {
        fprintf(stderr, "out of memory\n");
        return 1;
    }
    int err;
    if ((err = soundio_connect(soundio))) {
        fprintf(stderr, "unable to connect: %s\n", soundio_strerror(err));
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    soundio_flush_events(soundio);
    int default_output_index = soundio_default_output_device_index(soundio);
    if (default_output_index < 0) {
        fprintf(stderr, "No output device\n");
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    struct SoundIoDevice *device = soundio_get_output_device(soundio, default_output_index);
    if (!device) {
        fprintf(stderr, "out of memory\n");
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    struct SoundIoOutStream *outstream = soundio_outstream_create(device);
    if (!outstream) {
        fprintf(stderr, "out of memory\n");
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    outstream->format = SoundIoFormatFloat32NE;
    outstream->write_callback = write_callback;
    if ((err = soundio_outstream_open(outstream))) {
        fprintf(stderr, "unable to open device: %s" "\n", soundio_strerror(err));
        <b>soundio_outstream_destroy(outstream);</b>
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    if ((err = soundio_outstream_start(outstream))) {
        fprintf(stderr, "unable to start device: %s\n", soundio_strerror(err));
        <b>soundio_outstream_destroy(outstream);</b>
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    for (;;) soundio_wait_events(soundio);
    <b>soundio_outstream_destroy(outstream);</b>
    <b>soundio_device_unref(device);</b>
    <b>soundio_destroy(soundio);</b>
}</code>
          </td>
        </tr>
      </table>
      <p>However, his Zig example had the unfair advantage of
        returning error values instead of printing error messages
        which takes more space.
        The following is a C function that
        matches the Zig version more closely:</p>
      <table>
        <tr>
          <td>
            <code>// Example retrofitted from Zig example by Andrew Kelley:
// <a href="https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s">https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s</a>

<b>#pragma Cedro 1.0</b>

int main(int argc, char **argv) {
    struct SoundIo *soundio = soundio_create();
    if (!soundio) { return SoundIoErrorNoMem; }
    <b>auto soundio_destroy(soundio);</b>

    int err;
    if ((err = soundio_connect(soundio))) return err;

    soundio_flush_events(soundio);

    const int default_output_index = soundio_default_output_device_index(soundio);
    if (default_output_index < 0) return SoundIoErrorNoSuchDevice;

    const struct SoundIoDevice *device = soundio_get_output_device(soundio, default_output_index);
    if (!device) return SoundIoErrorNoMem;
    <b>auto soundio_device_unref(device);</b>

    const struct SoundIoOutStream *outstream = soundio_outstream_create(device);
    if (!outstream) return SoundIoErrorNoMem;
    <b>auto soundio_outstream_destroy(outstream);</b>

    outstream->format = SoundIoFormatFloat32NE;
    outstream->write_callback = write_callback;

    if ((err = soundio_outstream_open(outstream))) return err;
    if ((err = soundio_outstream_start(outstream))) return err;

    while (true) soundio_wait_events(soundio);
}</code>
          </td>
          <td>
            <code>// Example retrofitted from Zig example by Andrew Kelley:
// <a href="https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s">https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s</a>

int main(int argc, char **argv) {
    struct SoundIo *soundio = soundio_create();
    if (!soundio) { return SoundIoErrorNoMem; }

    int err;
    if ((err = soundio_connect(soundio))) {
        <b>soundio_destroy(soundio);</b>
        return err;
    }

    soundio_flush_events(soundio);

    const int default_output_index = soundio_default_output_device_index(soundio);
    if (default_output_index < 0) {
        <b>soundio_destroy(soundio);</b>
        return SoundIoErrorNoSuchDevice;
    }

    const struct SoundIoDevice *device = soundio_get_output_device(soundio, default_output_index);
    if (!device) {
        <b>soundio_destroy(soundio);</b>
        return SoundIoErrorNoMem;
    }

    const struct SoundIoOutStream *outstream = soundio_outstream_create(device);
    if (!outstream) {
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return SoundIoErrorNoMem;
    }

    outstream->format = SoundIoFormatFloat32NE;
    outstream->write_callback = write_callback;

    if ((err = soundio_outstream_open(outstream))) {
        <b>soundio_outstream_destroy(outstream);</b>
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return err;
    }
    if ((err = soundio_outstream_start(outstream))) {
        <b>soundio_outstream_destroy(outstream);</b>
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return err;
    }

    while (true) soundio_wait_events(soundio);
    <b>soundio_outstream_destroy(outstream);</b>
    <b>soundio_device_unref(device);</b>
    <b>soundio_destroy(soundio);</b>
}</code>
          </td>
        </tr>
      </table>
      <p>The Cedro version is much closer,
        but his point still stands because the plain C version
        needs a lot of repeated code and is more fragile.
        And of course Zig has
        <a href="https://ziglang.org/learn/overview/">many other great features</a>.</p>

      <h3 id="deferred-resource-release-related-work">Related work <a class="anchor" href="#deferred-resource-release-related-work">#…-related-work</a></h3>
      <p>Apart from the already mentioned
        “<a href="#a-defer-mechanism-for-c"><em>A defer mechanism for C</em></a>”,
        there are macros that use a <code>for</code> loop as
        <code>for (<em>allocation and initialization</em>; <em>condition</em>; <em>release</em>) { <em>actions</em> }</code>
        [<a href="#note-defer-1" name="node-defer-1-ref">1</a>]
        or other techniques
        [<a href="#note-defer-2" name="node-defer-2-ref">2</a>].</p>
      <div id="note-defer-1">
        [<a href="#note-defer-1-ref">1</a>]
        “<em><a href="https://gustedt.gitlabpages.inria.fr/p99/p99-html/utilities.html#blocks">P99 Scope-bound resource management with for-statements</a></em>” from the same author (2010), “<em><a href="https://www.reddit.com/r/C_Programming/comments/46lpna/would_it_be_possible_to_create_a_scoped_lock/">Would it be possible to create a scoped_lock implementation in C?</a></em>” (2016), ”<em><a href="https://news.ycombinator.com/item?id=25419916">C compatible scoped locks</a></em>“ (2021), “<em><a href="https://www.youtube.com/watch?v=QpAhX-gsHMs&amp;t=1053s">Modern C and What We Can Learn From It - Luca Sas [ ACCU 2021 ] 00:17:18</a></em>”, 2021
        <!-- C++: , o “<em><a href="https://stackoverflow.com/questions/48117908/is-the-a-practical-way-to-emulate-go-language-defer-in-c-or-c-destructors">Is there a practical way to emulate GO language defer in C?</a></em>” -->
      </div>
      <div id="note-defer-2">
        [<a href="#note-defer-2-ref">2</a>]
        “<em><a href="https://www.reddit.com/r/C_Programming/comments/46lpna/would_it_be_possible_to_create_a_scoped_lock/">Would it be possible to create a scoped_lock implementation in C?</a></em>” (2016), “<em><a href="https://github.com/trws/libdefer#limitations">libdefer: Go-style defer for C</a></em>” (2016), “<em><a href="https://github.com/moon-chilled/Defer">A Defer statement for C</a></em>” (2020), “<em><a href="https://gist.github.com/jart/aed0fd7a7fa68385d19e76a63db687ff">Go-like defer for C that works with most optimization flag combinations under GCC/Clang</a></em>” (2021)
      </div>
      <p>Compilers like GCC and clang have non-standard features to do this
        like the <a href="https://echorand.me/site/notes/articles/c_cleanup/cleanup_attribute_c.html"><code>__cleanup__</code> variable attribute</a>.</p>
      <p>Cedro does not have the limitation of the deferred code having to be a function: it can be a code block, with or without conditionals, which allows for instance to emulate <a href="https://ziglang.org/learn/overview/#manual-memory-management">Zig’s <code>errdefer</code></a> by performing different actions in case of error:</p>
      <table>
        <tr>
          <td>
            <code>char* allocate_block(size_t n, char** err_p)
{
    char* result = malloc(n);
    <b>auto if (*err_p) {
        free(result);
        result = NULL;
    }</b>

    if (n > 10) {
        *err_p = "n is too big";
    }

    return result;
}</code>
          </td><td>
            <code>char* allocate_block(size_t n, char** err_p)
{
    char* result = malloc(n);

    if (n > 10) {
        *err_p = "n is too big";
    }

    <b>if (*err_p) {
        free(result);
        result = NULL;
    }</b>

    return result;
}</code>
          </td>
        </tr>
      </table>
    </section>

    <section id="label-break">
      <h2>Break out of <em>nested loops</em>: <a class="anchor" href="#label-break">#label-break</a></h2>
      <p>Converts <code><b>break</b> <em>label</em>;</code> or <code><b>continue</b> <em>label</em>;</code> into <code><b>goto</b> <em>label</em>;</code>. In C it’s only possible to break out of one loop at a time when using <code>break</code>, which is also a problem when the interruption comes from a <code>switch</code> block.</p>
      <table>
        <tr>
          <td>
            <code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

<b>#pragma Cedro 1.0</b>

int main(int argc, char* argv[])
{
  int x = 0, y = 0;
  int initial_x = 0;

<em>search_from_initial_x</em>:
  for (x = initial_x; x &lt; 100; ++x) {
    for (y = 0; y &lt; 100; ++y) {
      switch (x + y) {
        case 157:
          <b>break</b> <em>found_number_decomposition</em>;
        case 11:
          initial_x = 37;
          fprintf(stderr, "Jump from x=11 to x=%d\n",
                  initial_x);
          <b>continue</b> <em>search_from_initial_x</em>;
      }
    }
  } <em>found_number_decomposition</em>:

  if (x &lt; 100 || y &lt; 100) {
    fprintf(stderr, "Found %d = %d + %d\n",
            x + y, x, y);
  }

  return 0;
}</code>
          </td><td>
            <br/><br/><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char* argv[])
{
  int x = 0, y = 0;
  int initial_x = 0;

<em>search_from_initial_x</em>:
  for (x = initial_x; x &lt; 100; ++x) {
    for (y = 0; y &lt; 100; ++y) {
      switch (x + y) {
        case 157:
          <b>goto</b> <em>found_number_decomposition</em>;
        case 11:
          initial_x = 37;
          fprintf(stderr, "Jump from x=11 to x=%d\n",
                  initial_x);
          <b>goto</b> <em>search_from_initial_x</em>;
      }
    }
  } <em>found_number_decomposition</em>:

  if (x &lt; 100 || y &lt; 100) {
    fprintf(stderr, "Found %d = %d + %d\n",
            x + y, x, y);
  }

  return 0;
}</code>
          </td>
        </tr>
      </table>
      <p>The difference between <code>break …</code>, <code>continue …</code>, and <code>goto …</code> is in the restrictions:</p>
      <ul>
        <li><code>break <em>label</em></code> only allows forward jumps, and the label must go right after the end of the loop.</li>
        <li><code>continue <em>label</em></code> only backward jumps, and the label must go right before the start of the loop.</li>
        <li><code>goto <em>label</em></code> has no restrictions.</li>
      </uL>

      <p>It is part of the <a href="#deferred-resource-release">deferred resource release</a> macro:</p>
      <table>
        <tr>
          <td>
            <code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

<b>#pragma Cedro 1.0</b>

int main(int argc, char* argv[])
{
  int x = 0, y = 0;
  char *level1 = malloc(1);
  <b>auto free(level1);</b>
  int initial_x = 0;

<em>search_from_initial_x</em>:
  for (x = initial_x; x &lt; 100; ++x) {
    char *level2 = malloc(2);
    <b>auto free(level2);</b>
    for (y = 0; y &lt; 100; ++y) {
      char *level3 = malloc(3);
      <b>auto free(level3);</b>
      switch (x + y) {
        case 157:
          <b>break</b> <em>found_number_decomposition</em>;
        case 11:
          initial_x = 37;
          fprintf(stderr, "Jump from x=11 to x=%d\n",
                  initial_x);
          <b>continue</b> <em>search_from_initial_x</em>;
      }
    }
  } <em>found_number_decomposition</em>:

  if (x &lt; 100 || y &lt; 100) {
    fprintf(stderr, "Found %d = %d + %d\n",
            x + y, x, y);
  }

  return 0;
}</code>
          </td><td>
            <br/><br/><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char* argv[])
{
  int x = 0, y = 0;
  char *level1 = malloc(1);
  int initial_x = 0;

<em>search_from_initial_x</em>:
  for (x = initial_x; x &lt; 100; ++x) {
    char *level2 = malloc(2);
    for (y = 0; y &lt; 100; ++y) {
      char *level3 = malloc(3);
      switch (x + y) {
        case 157:
          <b>free(level3);</b>
          <b>free(level2);</b>
          <b>goto</b> <em>found_number_decomposition</em>;
        case 11:
          initial_x = 37;
          fprintf(stderr, "Jump from x=11 to x=%d\n",
                  initial_x);
          <b>free(level3);</b>
          <b>free(level2);</b>
          <b>goto</b> <em>search_from_initial_x</em>;
      }
      <b>free(level3);</b>
    }
    <b>free(level2);</b>
  } <em>found_number_decomposition</em>:

  if (x &lt; 100 || y &lt; 100) {
    fprintf(stderr, "Found %d = %d + %d\n",
            x + y, x, y);
  }

  <b>free(level1);</b>

  return 0;
}</code>
          </td>
        </tr>
      </table>
      <p>Using <code>goto</code> in general it can’t be guaranteed that the resources will be released correctly, but with the restrictions when using <code>break …</code> and <code>continue …</code> it does work.</p>
      <table>
        <tr><td><code>$ bin/cedrocc test/defer-label-break.c -std=c99 -pedantic-errors -Wall -fanalyzer -o /tmp/find-number-decomposition
$ valgrind --leak-check=yes /tmp/find-number-decomposition
…
Jump from x=11 to x=37
Found 157 = 58 + 99
==1077== 
==1077== HEAP SUMMARY:
==1077==     in use at exit: 0 bytes in 0 blocks
==1077==   total heap usage: 2,236 allocs, 2,236 frees, 6,683 bytes allocated
==1077== 
==1077== All heap blocks were freed -- no leaks are possible
==1077== 
==1077== For lists of detected and suppressed errors, rerun with: -s
==1077== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code></td></tr>
        </table>

      <h3 id="label-break-related-work">Related work <a class="anchor" href="#label-break-related-work">#…-related-work</a></h3>
      <p>The <a href="https://en.wikipedia.org/wiki/Structured_program_theorem#Implications_and_refinements">BLISS 11</a> programming language was the first that <a href="https://www.cs.tufts.edu/~nr/cs257/archive/ronald-brender/bliss.pdf#9">introduced labels for its <code>leave</code></a> keyword (analogous to C’s <code>break</code>) around 1974, and later other languages like Java, Javascript, and Go did the same with <code>continue</code> and <code>break</code>.</p>
    </section>

    <section id="slice-notation">
      <h2>Notation for array slices: <a class="anchor" href="#slice-notation">#slice-notation</a></h2>
      <p>Converts <code><b>array</b>[<b>start</b>..<b>end</b>]</code> into <code>&amp;<b>array</b>[<b>start</b>], &amp;<b>array</b>[<b>end</b>]</code>. The array/pointer value <code>array</code> can be just an identifier or in general an expression which, as it will be evaluated twice, must not have any side effects, just <a href="https://gcc.gnu.org/onlinedocs/gcc-11.2.0/cpp/Duplication-of-Side-Effects.html#Duplication-of-Side-Effects">like standard C preprocessor macros</a>.</p>
      <p>We can use it to improve the
        <a href="#loop-macros-vec-example">vector example</a>
        from the loop macro section:</p>
      <table>
        <tr>
          <td>
            <code>  append(&amp;words, <b>animals</b>[<b>0</b>..<b>2</b>]);
  append(&amp;words, <b>plants</b>[<b>0</b>..<b>3</b>]);
  append(&amp;words, <b>animals</b>[<b>2</b>..<b>4</b>]);
</code>
          </td><td>
            <code>  append(&amp;words, &amp;<b>animals</b>[<b>0</b>], &amp;<b>animals</b>[<b>2</b>]);
  append(&amp;words, &amp;<b>plants</b>[<b>0</b>], &amp;<b>plants</b>[<b>3</b>]);
  append(&amp;words, &amp;<b>animals</b>[<b>2</b>], &amp;<b>animals</b>[<b>4</b>]);
</code>
          </td>
        </tr>
      </table>

      <p>The end of the slice can have a positive sign to indicate that
        it is a relative position to the start of the slice:
        <code><b>array</b>[<b>start</b>..+<b>end</b>]</code> becomes
        <code>&amp;<b>array</b>[<b>start</b>], &amp;<b>array</b>[<b>start</b>+<b>end</b>]</code>.
        In this case, the advice about double execution of side effects applies to
        <code>start</code> in addition to <code>array</code>.</p>
      <table>
        <tr>
          <td>
            <code>  append(&amp;words, <b>animals</b>[<b>0</b>..<b>+2</b>]);
  append(&amp;words, <b>plants</b>[<b>0</b>..<b>3</b>]);
  append(&amp;words, <b>animals</b>[<b>2</b>..<b>+2</b>]);
</code>
          </td><td>
            <code>  append(&amp;words, &amp;<b>animals</b>[<b>0</b>], &amp;<b>animals</b>[<b>0+2</b>]);
  append(&amp;words, &amp;<b>plants</b>[<b>0</b>], &amp;<b>plants</b>[<b>3</b>]);
  append(&amp;words, &amp;<b>animals</b>[<b>2</b>], &amp;<b>animals</b>[<b>2+2</b>]);
</code>
          </td>
        </tr>
      </table>

      <p>If the slice is composed of more than one token, it will be wrapped in parentheses to make sure it is correct.</p>
      <table>
        <tr>
          <td>
            <code>  append(&amp;words, <b>(uint8_t*)animals</b>[<b>0</b>..<b>+2</b>]);
  append(&amp;words, <b>(uint8_t*)plants</b>[<b>0</b>..<b>3</b>]);
  append(&amp;words, <b>(uint8_t*)animals</b>[<b>2</b>..<b>+2</b>]);
</code>
          </td><td>
            <code>  append(&amp;words, &amp;<b>((uint8_t*)animals)</b>[<b>0</b>], &amp;<b>((uint8_t*)animals)</b>[<b>0+2</b>]);
  append(&amp;words, &amp;<b>((uint8_t*)plants)</b>[<b>0</b>], &amp;<b>((uint8_t*)plants)</b>[<b>3</b>]);
  append(&amp;words, &amp;<b>((uint8_t*)animals)</b>[<b>2</b>], &amp;<b>((uint8_t*)animals)</b>[<b>2+2</b>]);
</code>
          </td>
        </tr>
      </table>

      <p>It can be used in initializers, in which case the braces can be omitted:</p>
      <table>
        <tr>
          <td>
            <code>#include &lt;stdio.h&gt;

#pragma Cedro 1.0

typedef struct {
  const char* a;
  const char* b;
} char_slice_t;
const char* text = "uno dos tres";

/** Extract "dos" from `text`. */
int main(void)
{
  char_slice_t slice = <b>text</b>[<b>4</b>..+<b>3</b>]</b>;
  const char* cursor;
  for (cursor = slice.a; cursor != slice.b; ++cursor) {
    putc(*cursor, stderr);
  }
  putc('\n', stderr);
}</code>
          </td><td><br/><br/>
            <code>#include &lt;stdio.h&gt;

typedef struct {
  const char* a;
  const char* b;
} char_slice_t;
const char* text = "uno dos tres";

/** Extract "dos" from `text`. */
int main(void)
{
  char_slice_t slice = { <b>&amp;text</b>[<b>4</b>], <b>&amp;text</b>[<b>4+3</b>] };
  const char* cursor;
  for (cursor = slice.a; cursor != slice.b; ++cursor) {
    putc(*cursor, stderr);
  }
  putc('\n', stderr);
}</code>
          </td>
        </tr>
      </table>

      <p>This complete example shows a scrolling text marquee:</p>
      <table>
        <tr>
          <td>
            <code>#ifdef _WIN32
#include &lt;windows.h&gt;
// See https://stackoverflow.com/a/3930716/
int sleep_ms(int ms) { Sleep(ms); return 0; }
#else
#define _XOPEN_SOURCE 500
#include &lt;unistd.h&gt; // Deprecated but simple:
int sleep_ms(int ms) { return usleep(ms*1000); }
#endif

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

<b>#pragma Cedro 1.0</b>

typedef char utf8_char[5]; // As C string.
void
print_slice(const utf8_char* start,
            const utf8_char* end)
{
  while (start &lt; end) fputs(*start++, stdout);
}

int
main(int argc, char* argv[])
{
  size_t display_size = 8;
  if (argc &lt; 2) {
    fprintf(stderr, "Usage: marquee &lt;text&gt;\n",
            display_size);
    exit(1);
  }

  const char separator[] = " *** ";
  size_t len_bytes   = strlen(argv[1]);
  size_t len_separator = strlen(separator);
  char* m = malloc(len_bytes + len_separator);
  <b>auto free(m);</b>
  memcpy(m,             argv[1],   len_bytes);
  memcpy(m + len_bytes, separator, len_separator);
  len_bytes += len_separator;

  // Extract each character encoded as UTF-8,
  // which needs up to 4 bytes + 1 terminator.
  utf8_char* message =
    malloc(sizeof(utf8_char) * len_bytes);
  <b>auto free(message);</b>
  size_t len = 0;
  for (size_t end = 0; end &lt; len_bytes;) {
    const char b = m[end];
    size_t u;
    if      (0xF0 == (b &amp; 0xF8)) u = 4;
    else if (0xE0 == (b &amp; 0xF0)) u = 3;
    else if (0xC0 == (b &amp; 0xE0)) u = 2;
    else                         u = 1;
    if (end + u &gt; len_bytes) break;
    memcpy(&amp;message[len], &amp;m[end], u);
    message[end][u] = '\0';
    end += u;
    ++len;
  }

  if (len &lt; 2) {
    fprintf(stderr, "message text is too short.\n");
    exit(2);
  } else if (len &lt; display_size) {
    display_size = len - 1;
  }

  for (;;) {
    for (int i = 0; i &lt; len; ++i) {
      int rest = i + display_size &gt; len?
          i + display_size - len: 0;
      int visible = display_size - rest;
      print_slice(<b>message[i .. +visible]</b>);
      print_slice(<b>message[0 .. rest]</b>);
      putc('\r', stdout);
      fflush(stdout);
      sleep_ms(300);
    }
  }

  return 0;
}</code>
          </td><td><br/><br/><br/><br/>
            <code>#ifdef _WIN32
#include &lt;windows.h&gt;
// See https://stackoverflow.com/a/3930716/
int sleep_ms(int ms) { Sleep(ms); return 0; }
#else
#define _XOPEN_SOURCE 500
#include &lt;unistd.h&gt; // Deprecated but simple:
int sleep_ms(int ms) { return usleep(ms*1000); }
#endif

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

typedef char utf8_char[5]; // As C string.
void
print_slice(const utf8_char* start,
            const utf8_char* end)
{
  while (start &lt; end) fputs(*start++, stdout);
}

int
main(int argc, char* argv[])
{
  size_t display_size = 8;
  if (argc &lt; 2) {
    fprintf(stderr, "Usage: marquee &lt;text&gt;\n",
            display_size);
    exit(1);
  }

  const char separator[] = " *** ";
  size_t len_bytes   = strlen(argv[1]);
  size_t len_separator = strlen(separator);
  char* m = malloc(len_bytes + len_separator);
  memcpy(m,             argv[1],   len_bytes);
  memcpy(m + len_bytes, separator, len_separator);
  len_bytes += len_separator;

  // Extract each character encoded as UTF-8,
  // which needs up to 4 bytes + 1 terminator.
  utf8_char* message =
    malloc(sizeof(utf8_char) * len_bytes);
  size_t len = 0;
  for (size_t end = 0; end &lt; len_bytes;) {
    const char b = m[end];
    size_t u;
    if      (0xF0 == (b &amp; 0xF8)) u = 4;
    else if (0xE0 == (b &amp; 0xF0)) u = 3;
    else if (0xC0 == (b &amp; 0xE0)) u = 2;
    else                         u = 1;
    if (end + u &gt; len_bytes) break;
    memcpy(&amp;message[len], &amp;m[end], u);
    message[end][u] = '\0';
    end += u;
    ++len;
  }

  if (len &lt; 2) {
    fprintf(stderr, "message text is too short.\n");
    exit(2);
  } else if (len &lt; display_size) {
    display_size = len - 1;
  }

  for (;;) {
    for (int i = 0; i &lt; len; ++i) {
      int rest = i + display_size &gt; len?
          i + display_size - len: 0;
      int visible = display_size - rest;
      print_slice(<b>&message[i], &message[i+visible]</b>);
      print_slice(<b>&message[0], &message[rest]</b>);
      putc('\r', stdout);
      fflush(stdout);
      sleep_ms(300);
    }
  }

  <b>free(message);</b>
  <b>free(m);</b>

  return 0;
}
</code>
          </td>
        </tr>
      </table>

      <h3 id="slice-notation-related-work">Related work <a class="anchor" href="#slice-notation-related-work">#…-related-work</a></h3>
      <p>The notation <code>[a..b]</code> for array slices was
        <a href="https://en.wikipedia.org/wiki/Array_slicing#1968:_Algol_68">first defined in Algol 68</a>
        where it was an alternative to the primary notation <code>[a:b]</code>, and
        both have been adopted by other languages since then.
        The <code>[a..b]</code> form is used in <a href="https://www.adaic.org/">Ada</a>,
        <a href="https://www.perl.org/">Perl</a>, <a href="https://dlang.org/">D</a>, and
        <a href="https://www.rust-lang.org/">Rust</a>, for example.</p>
    </section>

    <section id="block-macros">
      <h2>Block macros: <a class="anchor" href="#block-macros">#block-macros</a></h2>
      <p>Formats a multi-line macro into a single line.</p>
      <p>C macros must be written all in one line,
        but some times you need to split them in several pseudo-lines
        and it gets tedious and error-prone
        to maintain all the newline escapes <code>\</code>.</p>
      <p>By adding braces <code>{</code> or <code>}</code>
        right after <code>#define</code>
        we can have <em>Cedro</em> do that for us:</p>
      <table>
        <tr>
          <td>
            <code>#define { macro(A, B, C)
/// Version of f() for type A.
f_##A(B, C) /// Without semicolon “;” at the end.
#define }

int main(void) {
    int x = 1, y = 2;
    macro(int, x, y);
    // → f_int(x, y);
}</code>
          </td><td>
            <code>#define macro(A, B, C)                                            \
/** Version of f() for type A. */                                 \
f_##A(B, C) /** Without semicolon “;” at the end. */              \
/* End #define */

int main(void) {
    int x = 1, y = 2;
    macro(int, x, y);
    // → f_int(x, y);
}</code>
          </td>
        </tr>
      </table>
      <p>In cases like this
        (“<a href="https://gcc.gnu.org/onlinedocs/gcc-11.2.0/cpp/Function-like-Macros.html#Function-like-Macros">function-like macros</a>”),
        since there is no semicolon after <code>f_##A(B, C)</code>
        tools such as source code editors
        (e.g. <a href="https://www.gnu.org/software/emacs/manual/html_node/ccmode/Macros-with-_003b.html">Emacs</a>)
        indent the code incorrectly.</p>
      <p>The solution is to leave it there for the editor,
        and add it too after
        <code>#define }</code> as <code>#define }<b>;</b></code>
        which directs Cedro to remove it from the definition.</p>
      <table>
        <tr>
          <td>
            <code>#define { macro(A, B, C)
/// Version of f() for type A.
f_##A(B, C)<b>;</b> /// Semicolon “;” removed by Cedro.
#define }<b>;</b>

int main(void) {
    int x = 1, y = 2;
    macro(int, x, y);
    // → f_int(x, y);
}</code>
          </td><td>
            <code>#define macro(A, B, C)                                            \
/** Version of f() for type A. */                                 \
f_##A(B, C) /** Semicolon “;” removed by Cedro. */                \
/* End #define */

int main(void) {
    int x = 1, y = 2;
    macro(int, x, y);
    // → f_int(x, y);
}</code>
          </td>
        </tr>
      </table>

      <p>Preprocessor directives are not allowed
        inside macros, so you can not use
        <code>#if</code>, <code>#include</code>, etc.</p>
      <p>Note: the directive must start exactly with
        <code>#define {</code> or <code>#define }</code>,
        with no more or less space between
        <code>#define</code> and the brace
        <code>{</code> or <code>}</code>.</p>
    </section>

    <section id="loop-macros">
      <h2>Loop macros: <a class="anchor" href="#loop-macros">#loop-macros</a></h2>
      <p>Repeat the lines between
        <code>#foreach { ...</code> and <code>#foreach }</code>
        replacing the given variables.
        These lines may contain macro definitions (<code>#define</code>)
        but the loop variables will not be expanded inside them.</p>
      <p>As in <code>#define</code>,
        the <code>##</code> serves to
         <a href="https://gcc.gnu.org/onlinedocs/cpp/Concatenation.html#Concatenation">join <em>tokens</em></a>
        so that if, for example,
        <code>T</code> is <code>float</code>,
        <code>Vec_##T</code> produces <code>Vec_float</code>.</p>
      <p>Inside the loop,
        any operator following a <code>#</code>
        (e.g. <code>#,</code>) gets omitted in the last iteration.</p>
      <table>
        <tr>
          <td>
            <code>typedef enum {
#foreach { <b>V</b> {<b>SPACE</b>, <b>NUMBER</b>, \
              <b>KEYWORD</b>, <b>IDENTIFIER</b>, <b>OPERATOR</b>}
  T_##<b>V</b>#,
#foreach }
} TokenType;</code>
          </td><td>
            <code>typedef enum {
  T_<b>SPACE</b>,
  T_<b>NUMBER</b>,
  T_<b>KEYWORD</b>,
  T_<b>IDENTIFIER</b>,
  T_<b>OPERATOR</b>
} TokenType;</code>
          </td>
        </tr>
      </table>

      <p>If a variable has the prefix <code>#</code>,
        <a href="https://gcc.gnu.org/onlinedocs/cpp/Stringizing.html#Stringizing">the result is a string with its contents</a>:
        if <code>T</code> is <code>float</code>,
        <code>char* name = #T;</code> produces
        <code>char* name = <b>"float"</b>;</code>.</p>
      <p>Loops can be nested,
        and the list of values can come from
        a variable defined in an outer loop.</p>
      <table>
        <tr>
          <td>
            <code>#foreach { <b>VALUES</b> {{<b>SPACE</b>, <b>NUMBER</b>, \
                    <b>KEYWORD</b>, <b>IDENTIFIER</b>, <b>OPERATOR</b>}}
typedef enum {
#foreach { <b>V</b> <b>VALUES</b>
  T_##<b>V</b>#,
#foreach }
} TokenType;

const char* const TokenType_STRING[] = {
#foreach { <b>V</b> <b>VALUES</b>
  #<b>V</b>#,
#foreach }
};
#foreach }
</code>
          </td><td>
            <code>typedef enum {
  T_<b>SPACE</b>,
  T_<b>NUMBER</b>,
  T_<b>KEYWORD</b>,
  T_<b>IDENTIFIER</b>,
  T_<b>OPERATOR</b>
} TokenType;

const char* const TokenType_STRING[] = {
  "<b>SPACE</b>",
  "<b>NUMBER</b>",
  "<b>KEYWORD</b>",
  "<b>IDENTIFIER</b>",
  "<b>OPERATOR</b>"
};</code>
          </td>
        </tr>
      </table>

      <p>It is possible to iterate several variables in parallel
        using tuples of variables and values,
        that must have the same number of elements:</p>
      <table>
        <tr>
          <td>
            <code>#foreach { {<b>TYPE</b>, <b>PREFIX</b>, <b>VALUES</b>} {                   \
  { <b>TokenType</b>, <b>T_</b>, {<b>SPACE</b>, <b>NUMBER</b>,                    \
                    <b>KEYWORD</b>, <b>IDENTIFIER</b>, <b>OPERATOR</b>} }, \
  { <b>PinConfig</b>, <b>M_</b>, {<b>INPUT</b>, <b>OUTPUT</b>} }                  \
  }
typedef enum {
#foreach { <b>V</b> <b>VALUES</b>
  PREFIX##<b>V</b>#,
#foreach }
} <b>TYPE</b>;

const char* const <b>TYPE</b>##_STRING[] = {
#foreach { <b>V</b> <b>VALUES</b>
  #<b>V</b>#,
#foreach }
};

#foreach }</code>
          </td><td>
            <code>typedef enum {
  <b>T_SPACE</b>,
  <b>T_NUMBER</b>,
  <b>T_KEYWORD</b>,
  <b>T_IDENTIFIER</b>,
  <b>T_OPERATOR</b>
} <b>TokenType</b>;

const char* const <b>TokenType</b>_STRING[] = {
  "<b>SPACE</b>",
  "<b>NUMBER</b>",
  "<b>KEYWORD</b>",
  "<b>IDENTIFIER</b>",
  "<b>OPERATOR</b>"
};

typedef enum {
  <b>M_INPUT</b>,
  <b>M_OUTPUT</b>
} <b>PinConfig</b>;

const char* const <b>PinConfig</b>_STRING[] = {
  "<b>INPUT</b>",
  "<b>OUTPUT</b>"
};

</code>
          </td>
        </tr>
      </table>

      <p>This example iterates over a list of fields
        to build a <code>struct</code>
        and the corresponding <code>print_...()</code> function.</p>
      <table>
        <tr>
          <td>
            <code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;

#pragma Cedro 1.0
void print_double(double n, FILE* out)
{
  fprintf(out, "%f", n);
}

typedef uint32_t Colour_ARGB;
void print_Colour_ARGB(Colour_ARGB c, FILE* out)
{
  if ((c &amp; 0xFF000000) == 0xFF000000) {
    fprintf(out, "#%.6X", c &amp; 0x00FFFFFF);
  } else {
    fprintf(out, "#%.8X", c);
  }
}

#foreach { <b>FIELDS</b> {{                              \
  { <b>double</b>,   <b>x</b>,         <b>/** X position. */</b>    }, \
  { <b>double</b>,   <b>y</b>,         <b>/** Y position. */</b>    }, \
  { <b>Colour_ARGB</b>, <b>colour</b>, <b>/** Colour 32 bit. */</b> }  \
  }}
typedef struct Point {
#foreach { {<b>TYPE</b>, <b>NAME</b>, <b>COMMENT</b>} <b>FIELDS</b>
  <b>TYPE</b> <b>NAME</b>; <b>COMMENT</b>
#foreach }
} Point;

void print_Point(Point point, FILE* out)
{
#foreach { {<b>TYPE</b>, <b>NAME</b>, <b>COMMENT</b>} <b>FIELDS</b>
  print_##<b>TYPE</b>(point.<b>NAME</b>, out); putc('\n', out);
#foreach }
}
#foreach }

int main(void)
{
  Punto punto = { .x = 12.3, .y = 4.56, .color = 0xFFa3f193 };
  imprime_Punto(punto, stderr);
}</code>
          </td><td><br/>
            <code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;

void print_double(double n, FILE* out)
{
  fprintf(out, "%f", n);
}

typedef uint32_t Colour_ARGB;
void print_Colour_ARGB(Colour_ARGB c, FILE* out)
{
  if ((c &amp; 0xFF000000) == 0xFF000000) {
    fprintf(out, "#%.6X", c &amp; 0x00FFFFFF);
  } else {
    fprintf(out, "#%.8X", c);
  }
}

typedef struct Point {
  <b>double</b> <b>x</b>; <b>/** X position. */</b>
  <b>double</b> <b>y</b>; <b>/** Y position. */</b>
  <b>Colour_ARGB</b> <b>colour</b>; <b>/** Colour 32 bit. */</b>
} Point;

void print_Point(Point point, FILE* out)
{
  print_<b>double</b>(point.<b>x</b>, out); putc('\n', out);
  print_<b>double</b>(point.<b>y</b>, out); putc('\n', out);
  print_<b>Colour_ARGB</b>(point.<b>colour</b>, out); putc('\n', out);
}

int main(void)
{
  Punto punto = { .x = 12.3, .y = 4.56, .color = 0xFFa3f193 };
  imprime_Punto(punto, stderr);
}
</code>
          </td>
        </tr>
      </table>

      <p id="loop-macros-vec-example">This complete example
        defines variants for the types
        <code>float</code>, <code>str</code>, and <code>cstr</code>
        of an array/vector of variable length
        with a function called <code>append_Vec_##T()</code> for each one.
        It then uses C11’s
        <code><a href="https://en.cppreference.com/w/c/language/generic">_Generic</a></code>
        to define a pseudo-<a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">polymorphic</a>
        <code>append()</code> function.</p>
      <table>
        <tr>
          <td>
            <code>#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt; // For memcpy().

typedef struct str { uint8_t* start; uint8_t* end; } str;
typedef char* cstr; // Type names must be single words.

<b>#pragma Cedro 1.0</b>

#foreach { <b>TYPES_LIST</b> {{<b>float</b>, <b>str</b>, <b>cstr</b>}}
#foreach { <b>T</b> <b>TYPES_LIST</b>
/** Vector (resizeable array) type. */
typedef struct {
  <b>T</b>* _;
  size_t len;
  size_t capacity;
} Vec_##<b>T</b>;

/** Append a slice to a vector of elements of this type. */
bool
append_Vec_##<b>T</b>(Vec_##<b>T</b> *v, const <b>T</b> *start, const <b>T</b> *end)
{
  const size_t to_add = (size_t)(end - start);
  if (v-&gt;len + to_add &gt; v-&gt;capacity) {
    const size_t new_capacity = v-&gt;len +
        (to_add &lt; v-&gt;len? v-&gt;len: to_add);
    <b>T</b> * const new_start =
        realloc(v-&gt;_, new_capacity * sizeof(<b>T</b>));
    if (!new_start) return false;
    v-&gt;_        = new_start;
    v-&gt;capacity = new_capacity;
  }
  memcpy(v-&gt;_ + v-&gt;len, start, to_add * sizeof(<b>T</b>));
  v-&gt;len += to_add;

  return true;
}

#foreach }
#foreach { <b>DEFINE</b> {<b>#define</b>} // Avoid joining lines.
<b>DEFINE</b> append(VEC, START, END) _Generic((VEC), \
#foreach { <b>T</b> <b>TYPES_LIST</b>
  Vec_##<b>T</b>*: append_Vec_##<b>T</b>#, \
#foreach }
  )(VEC, START, END)
#foreach }
#foreach }

#include &lt;stdio.h&gt;
int main(void)
{
  Vec_cstr words = {0};
  cstr animals[] = { "horse", "cat", "chicken", "dog" };
  cstr plants [] = { "radish", "wheat", "tomato" };
  append(&amp;words, &amp;animals[0], &amp;animals[2]);
  append(&amp;words, &amp;plants[0], &amp;plants[3]);
  append(&amp;words, &amp;animals[2], &amp;animals[4]);
  for (cstr *w = words._, *end = words._ + words.len;
       w != end; ++w) {
    fprintf(stderr, "Word: \"%s\"\n", *w);
  }
  return 0;
}</code>
          </td><td>
            <code>#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt; // For memcpy().

typedef struct str { uint8_t* start; uint8_t* end; } str;
typedef char* cstr; // Type names must be single words.

/** Vector (resizeable array) type. */
typedef struct {
  <b>float</b>* _;
  size_t len;
  size_t capacity;
} Vec_<b>float</b>;

/** Append a slice to a vector of elements of this type. */
bool
append_Vec_<b>float</b>(Vec_<b>float</b> *v, const <b>float</b> *start, const <b>float</b> *end)
{
  const size_t to_add = (size_t)(end - start);
  if (v-&gt;len + to_add &gt; v-&gt;capacity) {
    const size_t new_capacity = v-&gt;len +
        (to_add &lt; v-&gt;len? v-&gt;len: to_add);
    <b>float</b> * const new_start =
        realloc(v-&gt;_, new_capacity * sizeof(<b>float</b>));
    if (!new_start) return false;
    v-&gt;_        = new_start;
    v-&gt;capacity = new_capacity;
  }
  memcpy(v-&gt;_ + v-&gt;len, start, to_add * sizeof(<b>float</b>));
  v-&gt;len += to_add;

  return true;
}

/** Vector (resizeable array) type. */
typedef struct {
  <b>str</b>* _;
  size_t len;
  size_t capacity;
} Vec_<b>str</b>;

/** Append a slice to a vector of elements of this type. */
bool
append_Vec_<b>str</b>(Vec_<b>str</b> *v, const <b>str</b> *start, const <b>str</b> *end)
{
  const size_t to_add = (size_t)(end - start);
  if (v-&gt;len + to_add &gt; v-&gt;capacity) {
    const size_t new_capacity = v-&gt;len +
        (to_add &lt; v-&gt;len? v-&gt;len: to_add);
    <b>str</b> * const new_start =
        realloc(v-&gt;_, new_capacity * sizeof(<b>str</b>));
    if (!new_start) return false;
    v-&gt;_        = new_start;
    v-&gt;capacity = new_capacity;
  }
  memcpy(v-&gt;_ + v-&gt;len, start, to_add * sizeof(<b>str</b>));
  v-&gt;len += to_add;

  return true;
}

/** Vector (resizeable array) type. */
typedef struct {
  <b>cstr</b>* _;
  size_t len;
  size_t capacity;
} Vec_<b>cstr</b>;

/** Append a slice to a vector of elements of this type. */
bool
append_Vec_<b>cstr</b>(Vec_<b>cstr</b> *v, const <b>cstr</b> *start, const <b>cstr</b> *end)
{
  const size_t to_add = (size_t)(end - start);
  if (v-&gt;len + to_add &gt; v-&gt;capacity) {
    const size_t new_capacity = v-&gt;len +
        (to_add &lt; v-&gt;len? v-&gt;len: to_add);
    <b>cstr</b> * const new_start =
        realloc(v-&gt;_, new_capacity * sizeof(<b>cstr</b>));
    if (!new_start) return false;
    v-&gt;_        = new_start;
    v-&gt;capacity = new_capacity;
  }
  memcpy(v-&gt;_ + v-&gt;len, start, to_add * sizeof(<b>cstr</b>));
  v-&gt;len += to_add;

  return true;
}

#define append(VEC, START, END) _Generic((VEC), \
  Vec_<b>float</b>*: append_Vec_<b>float</b>, \
  Vec_<b>str</b>*: append_Vec_<b>str</b>, \
  Vec_<b>cstr</b>*: append_Vec_<b>cstr</b> \
  )(VEC, START, END)

#include &lt;stdio.h&gt;
int main(void)
{
  Vec_cstr words = {0};
  cstr animals[] = { "horse", "cat", "chicken", "dog" };
  cstr plants [] = { "radish", "wheat", "tomato" };
  append(&amp;words, &amp;animals[0], &amp;animals[2]);
  append(&amp;words, &amp;plants[0], &amp;plants[3]);
  append(&amp;words, &amp;animals[2], &amp;animals[4]);
  for (cstr *w = words._, *end = words._ + words.len;
       w != end; ++w) {
    fprintf(stderr, "Word: \"%s\"\n", *w);
  }
  return 0;
}</code>
          </td>
        </tr>
      </table>
    </section>

    <section id="binary-include">
      <h2>Binary inclusion: <a class="anchor" href="#binary-include">#binary-include</a></h2>
      <p>Inserts a file as a byte array,
        or as literal strings as described below.</p>
      <p>The name of the file is relative to the including C file.</p>
      <table>
        <tr>
          <td>
            <code>#include &lt;stdint.h&gt;
<b>#pragma Cedro 1.0 #embed</b>
const uint8_t image[] = {
<b>#embed "../images/cedro-32x32.png"</b>
};</code>
          </td><td>
            <br/><code>#include &lt;stdint.h&gt;
const uint8_t image[] = {
/* cedro-32x32.png */
<b>0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,…
0x00,0x00,0x00,0x20,0x00,0x00,0x00,…
⋮</b>
};</code>
          </td>
        </tr>
        <tr><td colspan="2">
      <p>The form <code>#include {...}</code> was the original in Cedro
        and is kept for backwards compatibility,
        while <code>#embed "..."</code> follows the future C23 standard
        (“<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3017.htm">N3017 #embed - a scannable, tooling-friendly binary resource inclusion mechanism</a>”)
        except that it only accepts
        paths delimited by quotes (<code>""</code>),
        not delimited by chevrons (<code>&lt;&gt;</code>).
      </p>
      <p>Note: when using <code>#include {</code>
        there must be no more or less space between
        <code>#include</code> and the brace <code>{</code>.</p>
        </td></tr>
        <tr>
          <td>
            <code>#include &lt;stdint.h&gt;
<b>#pragma Cedro 1.0</b>
const uint8_t image
<b>#include {../images/cedro-32x32.png}</b>
;</code>
          </td><td>
            <br/><code>#include &lt;stdint.h&gt;
const uint8_t image
<b>[1559] = {</b> /* cedro-32x32.png */
<b>0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,…
0x00,0x00,0x00,0x20,0x00,0x00,0x00,…
⋮</b>
};</code>
          </td>
        </tr>
      </table>
      <p><code>#embed</code> is more flexible because it allows adding bytes
        before or after the inserted file,
        and also to combine several files.</p>
      <table>
        <tr>
          <td>
            <code><b>#pragma Cedro 1.0 #embed</b>
const char const vertex_shader[] = {
<b>#embed "shader.frag.glsl"</b>
, 0x00 // Zero-terminated string.
};</code>
          </td><td>
            <br/><code>const char const vertex_shader[] = {
/* shader.frag.glsl */
<b>0x23,0x76,0x65,0x72,0x73,0x69,0x6F,0x6E,…
0x65,0x63,0x69,0x73,0x69,0x6F,0x6E,0x20,…
⋮</b>
, 0x00 // Zero-terminated string.
};</code>
          </td>
        </tr>
        <tr>
          <td>
            <code><b>#pragma Cedro 1.0 #embed</b>
const char const two_lines[] = {
<b>#embed "text-line-1.txt"</b>
, '\n',
<b>#embed "text-line-2.txt"</b>
, 0x00
};</code>
          </td><td>
            <br/><code>const char const two_lines[] = {
<b>0x46,0x69,0x72,0x73,0x74,0x20,0x6C,0x69,0x6E,0x65,0x2E</b>
, '\n',
<b>0x53,0x65,0x63,0x6F,0x6E,0x64,0x20,0x6C,0x69,0x6E,0x65,0x2E</b>
, 0x00
};</code>
          </td>
        </tr>
      </table>

      <h3 id="embed-as-string">Embed as string</h3>
      <p>Instead of inserting byte literals one by one,
        they can be put all at once in a literal string
        with the option <code>--embed-as-string=&lt;limit&gt;</code>,
        although this variant has certain limitations
        depending on the C compiler that will be used with the result.</p>
      <p>For instance, the Microsoft C compiler has a limit of
        2048 bytes for each string literal, with a maximum of
        65535 after concatenating the strings that appear together.
        (See “<a href="https://docs.microsoft.com/en-us/cpp/c-language/maximum-string-length?view=msvc-170">Maximum String Length</a>”)</p>
      <p>The ANSI/ISO C standard requires that all compilers accept
        at least 509 bytes in total after concatenation
        in C89, and 4096 in C99/C11/C17,
        but other compilers such as GCC and clang
        allow much bigger strings.
      </p>
      <p>That’s why it’s necessary to specify a limit for the size:
        if the file is greater goes over that limit,
        the result will be an array of bytes instead of a string.</p>
      <p>In an informal test <code>/usr/bin/time -v</code>,
        taking the fastest run values with an 8 MB file,
        on an IBM Power9 CPU with the files on RAM disk,
        the code generation took 26% less time
        than when using hexadecimal bytes,
        and the compilation with GCC was <b>28 times faster</b>
        using 10 times less memory.
        With clang the compilation was <b>72 times</b> faster
        than with bytes,
        using 7 times less memory.</p>
      <table class="benchmark">
        <tr><th></th><th colspan="2">Generate code</th><th colspan="2">Compile with GCC 11</th><th colspan="2">Compile with clang 12</th></tr>
        <tr><th><code>cedro</code></th><td>0.19 s</td><td>1.80 MB</td><td>27.66 s</td><td>1328.13 MB</td><td>30.44 s</td><td>984.59 MB</td></tr>
        <tr><th><code>cedro --embed-as-string=…</code></th><td>0.14 s</td><td>1.63 MB</td><td>0.99 s</td><td>125.32 MB</td><td>0.42 s</td><td>144.95 MB</td></tr>
        <tr><th><code>bin2c</code></th></th><td>0.03 s</td><td>1.37 MB</td><td>0.90 s</td><td>108.70 MB</td><td>0.52 s</td><td>145.73 MB</td></tr>
      </table>
      <p>In comparison with
        <a href="#binary-include-related-work"><code>bin2c</code></a>,
        the code generation took five times more time,
        and the compilation is very similar
        (±100ms, bin2c’s result compiles faster on GCC,
        Cedro’s on clang)
        because the format is
        <a href="#binary-include-related-work">almost the same</a>.</p>
      <table>
        <tr>
          <td>
            <code><b>#pragma Cedro 1.0 #embed</b>
const char const dos_líneas[] = {
<b>#embed "línea-de-texto-1.txt"</b>
, '\n',
<b>#embed "línea-de-texto-2.txt"</b>
, 0x00
};</code>
          </td><td>
            <code class="command-line-option" title="Insert as string if the file is smaller than 30 bytes.">--embed-as-string=30</code>
            <code>const char const two lines[<b>25</b>] =
/* text-line-1.txt */
<b>"First line.""\n"</b>
/* text-line-2.txt */
<b>"Second line."</b>;</code>
          </td>
        </tr>
        <tr><td colspan="2">
            <p>Note how Cedro realizes that the last byte is zero
              and removes it, because since there is a string just before,
              the compiler will add the zero terminator automatically..</p>
          </td>
        </tr>
        <tr>
          <td>
            <code><b>#pragma Cedro 1.0 #embed</b>
const char const fragment_shader[] = {
<b>#embed "shader.frag.glsl"</b>
, 0x00 // Zero-terminated string.
};</code>
          </td><td>
            <code class="command-line-option" title="Insert as string if the file is smaller than 170 bytes.">--embed-as-string=170</code>
            <code>const char const fragment_shader[<b>164</b>] = 
/* shader.frag.glsl */
<b>"#version 140\n"
"\n"
"precision highp float; // needed only for version 1.30\n"
"\n"
"in  vec3 ex_Color;\n"
"out vec4 out_Color;\n"
"\n"
"void main(void)\n"
"{\n"
"\tout_Color = vec4(ex_Color,1.0);\n"
"}\n"</b>;</code>
          </td>
        </tr>
        <tr>
          <td>
            <code>#include &lt;stdint.h&gt;
<b>#pragma Cedro 1.0 #embed</b>
const uint8_t image[] = {
<b>#embed "../images/cedro-32x32.png"</b>
};</code>
          </td><td>
            <code class="command-line-option" title="Insert as string if the file is smaller than 1600 bytes.">--embed-as-string=1600</code>
            <code>#include &lt;stdint.h&gt;
const uint8_t image[<b>1559</b>] = <b>/* cedro-32x32.png */
"\211PNG\r\n"
"\032\n"
"\000\000\000\rIHDR\000\000\000 \000\000\000 \b\002…"
⋮
…"</b>;</code>
          </td>
        </tr>
        <tr>
          <td>
            <code>#include &lt;stdint.h&gt;
<b>#pragma Cedro 1.0</b>
const uint8_t image
<b>#include {../images/cedro-32x32.png}</b>
;</code>
          </td><td>
            <code class="command-line-option" title="Insert as string if the file is smaller than 1600 bytes.">--embed-as-string=1600</code>
            <code>#include &lt;stdint.h&gt;
const uint8_t image
[<b>1559</b>] = { /* cedro-32x32.png */
<b>"\211PNG\r\n"
"\032\n"
"\000\000\000\rIHDR\000\000\000 \000\000\000 \b\002…"
⋮
…"</b>;</code>
          </td>
        </tr>
      </table>

      <p>Directly inserting the code in the program is very convenient
        but it will slow down compilation.
        The way to reduce the problem,
        apart from using <code>--embed-as-string=&lt;limit&gt;</code>,
        is to compile this part separately
        as can be seen in <url>template/Makefile.nanovg.mk</url>
        or in this example:
        another way would be to use <a href="https://gcc.gnu.org/onlinedocs/gcc-12.1.0/gcc/Precompiled-Headers.html#Precompiled-Headers">precompiled headers</a>)</p>
      <table>
        <tr><td><url>assets.c</url><code>#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

<b>#pragma Cedro 1.0 #embed</b>

const uint8_t image[] = {
<b>#embed "../images/cedro-32x32.png"</b>
};
const size_t sizeof_image = sizeof(image);</code></td></tr>
        <tr><td><url>main.c</url><code>#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

extern const uint8_t image[];
extern const size_t sizeof_image;

int main(void)
{
    unsigned int sum = 0;
    for (size_t i = 0; i < sizeof_image; ++i) {
        sum += image[i];
    }
    fprintf(stderr,
            "The sum (modulo UINT_MAX=%u) of the image bytes is %u.\n",
            UINT_MAX, sum);
}</code></td></tr>
         <tr><td><code>cedrocc -c -o assets.o assets.c -std=c99
cedrocc -c -o main.o   main.c   -std=c99
cc -o program main.o assets.o</code></td></tr>
      </table>

      <h3 id="binary-include-related-work">Related work <a class="anchor" href="#binary-include-related-work">#…-related-work</a></h3>
      <p>This feature is an old idea
        and there are several implementations, for instance
        <a href="https://github.com/ConorOG/xxd">xxd</a>
        (as <code>xxd -i</code>, <a href="http://manpages.ubuntu.com/manpages/bionic/man1/xxd.1.html">man page</a>)
        which I used many years ago and has it since 1994.</p>
      <p>More recently,
        the <code><a href="https://doc.rust-lang.org/std/macro.include_bytes.html">include_bytes!()</a></code> macro
        has been very useful to me in my Rust programs.</p>
      <p>I got the idea of producing string literals
        instead of byte arrays from this comment:</p>
      <blockquote>
        <p>the way that you’ve lowered them is absolutely the worst case for compiler performance. The compiler needs to create a literal constant object for every byte and an array object wrapping them. If you lower them as C string literals with escapes, you will generate code that compiles much faster. For example, the cedro-32x32.png example lowered as “\x89\x50\x4E\x47\0D\x0A\x1A…” will be faster and use less memory in the C compiler.</p>
        <address><a href="https://lobste.rs/s/18axic/c_programming_language_extension_cedro#c_vwpvzk">David Chisnall in Lobsters, 2021-08-12</a></address>
      </blockquote>
      <blockquote>
        <p>I did not realize that, you are right of course! I know there are limits to the size of string literals, but maybe that does not apply if you split them. I’ll have to check that out.</p>
        <p>EDIT: I’ve just found out that bin2c (which I knew existed but haven’t used) does work in the way you describe, with strings instead of byte arrays: https://github.com/adobe/bin2c#comparison-to-other-tools It does mention the string literal size limit. I suspect you know, but for others reading this: the C standard defines some sizes that all compilers must support as a minimum, and one of them is the string literal maximum size. Compilers are free to allow bigger tokens when parsing.</p>
        <p>I’m concerned that it would be a problem, because as I hinted above my use case includes compiling on old platforms with outdated C compilers (sometimes for fun, others because my customers need that) so it is important that cedro does not fail any more than strictly necessary when running on unusual machines.</p>
        <p>Thinking about it, I could use strings when under the length limit, but those would be the cases where the performance difference would be small. I’ll keep things like this for now, but thanks to you I’ll take these aspects into account. EDIT END.</p>
        <address><a href="https://lobste.rs/s/18axic/c_programming_language_extension_cedro#c_mydhp1">Alberto González Palomo in Lobsters, 2021-08-12</a></address>
      </blockquote>
        <p>An example of this method is
          Adobe’s <a href="https://github.com/adobe/bin2c">bin2c</a>
          published in 2020 (not the same as the
          <a href="https://github.com/gwilymk/bin2c">bin2c of 2012</a>
          that produces byte literals like <code>xxd</code>),
          and although I haven’t looked in its source code,
          Cedro follows
          <a href="https://github.com/adobe/bin2c#encoding">the specification in its documentation</a>
          except the ends of line, where Cedro splits the string literal
          in the same way as is usually done by hand
          and also limits the size of each individual string to 500 bytes
          in the hope of it working on old compilers.</p>
        <p>More references with information on other methods:</p>
        <ul>
          <li>“<a href="http://gareus.org/wiki/embedding_resources_in_executables">Embedding Blobs in Binaries</a>”, ca. 2014, Robin Gareus. Discussion: <a href="https://news.ycombinator.com/item?id=8656856">Hacker News 2014-11-25</a></li>
          <li>“<a href="https://www.devever.net/~hl/incbin">Embedding of binary data into programs</a>”, 2016-01-15, Hugo Landau.</a></li>
          <li>“<a href="https://csl.name/post/embedding-binary-data/">Embedding binary data in executables</a>”, 2016-06-07, Christian Stigen Larsen.</li>
          <li>“<a href="https://drewdevault.com/2018/05/29/Embedding-files-in-C.html">Embedding files in C programs with kolo</a>”, 2018-05-29, Drew DeVault. Discussion: <a href="https://news.ycombinator.com/item?id=17191119">Hacker News 2018-05-30</a></li>
          <li>“<a href="https://flak.tedunangst.com/post/embedding-binary-objects-in-c">Embedding binary objects in c</a>”, 2020-04-16, Ted Unangst. Discussion: <a href="https://lobste.rs/s/9zvyeu/embedding_binary_objects_c">Lobsters 2020-04-16</a>, <a href="https://news.ycombinator.com/item?id=22888318">Hacker News 2020-04-16</a></li>
          <li>“<a href="https://cupdev.net/blog/013_bin2c.html">How to Analyze Assembly Code to Guide Optimization Strategies</a>” <em>(Describing Adobe’s bin2c’s implementation)</em>, 2020-05-29, Karolin Varner. Discussion: <a href="https://www.reddit.com/r/C_Programming/comments/gsxvh3/how_to_analyze_assembly_code_to_guide/">Reddit 2020-05-29</a></li>
          <li>“<a href="https://thephd.dev/finally-embed-in-c23">#embed is in C23</a>”, 2022-07-23, JeanHeyd Meneide. Discussion: <a href="https://lobste.rs/s/vwqjil/finally_embed_c">Lobsters 2022-07-23</a>, <a href="https://news.ycombinator.com/item?id=32201951">Hacker News 2022-07-23</a></li>
          <li>“<a href="https://tratt.net/laurie/blog/2022/whats_the_most_portable_way_to_include_binary_blobs_in_an_executable.html">What’s the Most Portable Way to Include Binary Blobs in an Executable?</a>”, 2022-07-25, Laurence Tratt. Discussion: <a href="https://lobste.rs/s/xhwvur/what_s_most_portable_way_include_binary">Lobsters 2022-07-25</a></li>
        </ul>
    </section>

    <a class="link-to-table-of-contents" href="#">↑ Contents</a>
    <footer>
      The Blue Atlas Cedar tree in the icon is the <a href="https://www.bonsai-nbf.org/collections#America">Silver Phoenix</a> bonsai at the <a href="https://usna.usda.gov/">US National Arboretum</a>.
    </footer>
  </body>
</html>
