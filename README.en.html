<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>C programming language extension: Cedro pre-processor</title>
    <style type="text/css">@font-face { font-family: 'sorts_mill_goudyregular'; src: local('OFL Sorts Mill Goudy TT'), url('doc/fonts/GoudyStM-webfont.woff') format('woff'); font-weight: normal; font-style: normal; } html { background:#111; } section, footer { font-family:sans-serif; line-height:1.5; max-width:82em; margin:0.5em auto 0.5em auto; background:#222; color:#c92; text-shadow:0 0.1em 0.1em #000; border:thin solid #222; padding:1em; } section + section, section + footer { margin-top:2em; } section>h2:first-child { margin-top:0; } p,ul,table { } a, a:visited { color:#99e; text-decoration:none; box-shadow:0 2px 1px -1px #77e; } a.img { box-shadoorw:none; } a.img > img { vertical-align:bottom; } a>code { border-bottom:none; background-color:transparent; } code>a { color:inherit !important; } code { display:inline; vertical-align:baseline; padding:0; background:#111; color:#8d8; border:thin solid #333; border-radius:0.25em; padding:0.25em; font-family:'Input', 'Fira Code', 'monospace'; white-space:pre-wrap; } section > code, td > code { display:inline-block; vertical-align:baseline; overflow-wrap:anywhere; word-break:break-all; } h1 { font-size:200%; margin:0; background-color:#070707; color:#eee; font-family:sorts_mill_goudyregular, serif; font-weight:normal; } h1::after { clear:both; content:""; display:block; } h1>img { vertical-align:bottom; } h2 { font-size:128%; } h3 { font-size:116%; } h4 { font-size:110%; } h2, h3, h4 { font-family:sans-serif; font-weight:normal; color:#c72; border-left:0.75rem solid rgba(204,119,34,0.25); margin-left:-1rem; margin-right:-0.25rem; padding-left:0.25rem; padding-right:0.25rem; } h1>a.anchor, h2>a.anchor, h3>a.anchor, h4>a.anchor { visibility:hidden; } h1:hover>a.anchor, h2:hover>a.anchor, h3:hover>a.anchor, h4:hover>a.anchor { visibility:visible; } table { border-collapse:collapse; background:inherit; } th, td { vertical-align:top; border:thin solid #777; padding:0.5em; } th { font-weight:normal; } p,ul { max-width:50em; text-align:justify; } .language-selector { padding:0.25rem; font-size:1rem; } .link-to-table-of-contents { background:#111; padding:0.25em; position:fixed; bottom:0; right:0; } @media (prefers-color-scheme:light) { html { background:#ddd; } section, footer { background:#eee; color:#111; text-shadow:none; border-color:#ccc; } a, a:visited { color:#11d; box-shadow:0 2px 1px -1px #ccd; } h1 a, h1 a:visited { color:#ccf; } code { background:#f7f7f7; color:#000; border-color:#eee; } h2, h3, h4 { color:#222; border-color: rgba(34,34,34,0.15); } .link-to-table-of-contents { background:#ddd; } }</style>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
  </head>
  <body>
    <section>
      <h1 style="text-align:center"><span style="float:left"><a href="https://sentido-labs.com/en/library/" class="img"><img alt="Atlas blue cedar" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABABAMAAABYR2ztAAAAGFBMVEUAAAAWLxcoYCg5izpCsUNN1U1b9Fp7+3umzZ3RAAAAI2lUWHRBdXRob3IAAAAAAEFsYmVydG8gR29uesOhbGV6IFBhbG9tb8X116oAAAGpSURBVEjH5ZTBdpswEEWBnO4dO+dkawTZxwjsbQwjs66R4ANAow+Ipfn9qq7betUgs+xbcpir0byniaL/UElerOIF9Vl7ORBdinT1IOCVyEnVnJDMxyP1cYudR5D5HJqetuGAjW//oITSveqJ7DGc8G3aGzKOJTUTvcQpGJBmMOgz32Rc9NYgjkWgJS9y6CcFNedZCQorZagMMuRJK9e09vycsRzKhhUlSqyDCKsorXo0NEDBSgWclzCF2ZGsr//nOxZF6zROTuMxMAo+Bxr7UQiUSnLgVbMPCNXGJ9kaPRApIkLddnv8WMXn+beIcwCyvg3jENFYdD+jiUg8ZBLJUUjv4vTmnFGocRLaeBDtnmeboRSisjw/thYt+kghoK3M5+weXK+0kg2HZhvDwXo3kMhcqnHeHGIx+TP1SSifpvco/n7LaXdKZzbQErqxY+uMcYB8+8hqaN0twQlIqB9aLn/OLQXA+6JN+6SlhNUiBICQ3SJEpfwoFt3jTYFHdEE1/F5VzXabOmXw99PXBLw+qN/y2/qa6V/y7wu/JtCdbixyd4wZPfxb+geh0KANiaQN5QAAAABJRU5ErkJggg==" width="64" height="64"/></a> Cedro</span>
        <span class="language-selector"><a href="README.es.html">Español</a>, English</span>
        <a style="display:inline-block;float:right;font-size:1rem;padding:0.5em" href="http://sentido-labs.com" class="img"><img alt="Sentido-Labs.com" src="doc/sentido-labs-mono.svg" style="width:5em" width="157" height="33"/></a>
      </h1>
      <p style="clear:both"><em>Cedro</em> is a C language extension that works as a pre-processor with six features:</p>
      <ol>
        <li>The <a href="#backstitch-macro"><em>backstitch</em> <code>@</code> macro</a> (<a href="#backstitch-macro-related-work">related work</a>).</li>
        <li><a href="#deferred-resource-release"><em>Deferred</em> resource release <code>auto ...</code></a> (<a href="#deferred-resource-release-related-work">related work</a>).</li>
        <li><a href="#block-macros"><em>Block</em> macros <code>#define { ... #define }</code></a><!-- (<a href="#block-macros-related-work">related work</a>)-->.</li>
        <li><a href="#loop-macros"><em>Loop</em> macros <code>#foreach { ... #foreach }</code></a><!-- (<a href="#loop-macros-related-work">related work</a>)-->.</li>
        <li><a href="#slice-notation">Notation for array <em>slices</em> <code>array[start..end]</code></a> (<a href="#slice-notation-related-work">related work</a>).</li>
        <li><a href="#binary-include"><em>Binary</em> inclusion <code>#include {...}</code></a> (<a href="#binary-include-related-work">related work</a>).</li>
      </ol>
      <p>To activate it, the source file must contain this line:
        <code>#pragma Cedro 1.0</code><br/>
        Otherwise, the file is copied directly to the output.</p>
      <code>Usage: cedro [options] file.c [file2.c … ]
  The result goes to stdout, can be used without an intermediate file like this:
 cedro file.c | cc -x c - -o file
  It is what the cedrocc program does:
 cedrocc -o file file.c
  With cedrocc, the following options are the defaults:
    --discard-comments --insert-line-directives

  --apply-macros     Applies the macros: backstitch, defer, etc. (default)
  --escape-ucn       Escapes non-ASCII in identifiers as UCN.
  --no-apply-macros  Does not apply the macros.
  --no-escape-ucn    Does not escape non-ASCII in identifiers. (default)
  --discard-comments    Discards the comments.
  --discard-space       Discards all whitespace.
  --no-discard-comments Does not discard comments.   (default)
  --no-discard-space    Does not discard whitespace. (default)
  --insert-line-directives    Inserts #line directives.
  --no-insert-line-directives Does not insert #line directives. (default)

  --print-markers    Prints the markers.
  --no-print-markers Does not print the markers. (default)
  --enable-core-dump    Enables core dump on crash.
  --no-enable-core-dump Does not enable core dump on crash. (default)
  --benchmark        Runs a performance benchmark.
  --version          Shows version: 1.0
                     The corresponding “pragma” is: #pragma Cedro 1.0</code>
      <p>The option <code>--escape-ucn</code> encodes Unicode® characters
        outside of the ASCII range, when they appear as part of an identifier,
        as C99 universal character names
        (“C99 standard”, page 65, “<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf#65">6.4.3 Universal character names</a>”),
        which can be useful for older compilers without UTF-8 support such as
        <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67224#c32">GCC before version 10</a>.</p>
      <p>For API documentation, see <a href="doc/api/index.html">doc/api/index.html</a>
        after running <code>make doc</code> that requires having
        <a href="https://www.doxygen.nl/index.html">Doxygen</a> installed.</p>
      <p>The second executable, <code>cedrocc</code>, allows using Cedro as if it was part of the C compiler.</p>
      <code>Usage: cedrocc [options] &lt;file.c&gt; [ file2.o … ]
  Runs Cedro on the first file name that ends with “.c”,
  and compiles the result with “cc -x c -” plus the other arguments.
    cedrocc -o fichero fichero.c
    cedro fichero.c | cc -x c - -o fichero
  You can specify the compiler, e.g. gcc:
    CEDRO_CC='gcc -x c -' cedrocc …
  For debugging, this writes the code that would be piped into cc,
  into stdout instead:
    CEDRO_CC='' cedrocc …</code>
      <p>If you get an error message like “embedding a directive within macro arguments is not portable” (GCC) or “embedding a directive within macro arguments has undefined behavior” (clang), it means that you’re using Cedro with <code>--insert-line-directives</code> inside the parameters for a macro. You can either expand the code given to the macro manually, or avoid <code>--insert-line-directives</code> by replacing <code>cedrocc -o file file.c</code> with <code>cedro file.c | cc -x c - -o file</code>.</p>
      <p>There is a third executable, <code>cedro-new</code>, that produces a program draft in a similar way to <code>cargo new</code> in Rust. <code>cedro new …</code> will actually run <code>cedro-new …</code>. The content is produced from the template in the <code>template/</code> directory, that gets included in the <code>cedro-new</code> executable at compilation.</p>
      <code>Usage: cedro-new [options] &lt;name&gt;
  Creates a directory named &lt;name&gt;/ with the template.
  -h, --help        Shows this message.
  -i, --interactive Asks for the names for command and project.
                    Otherwise, they will be derived from the directory name.</code>
    </section>

    <section id="backstitch-macro">
      <h2><a href="https://en.wikipedia.org/wiki/Backstitch">Backstitch</a> macro: @ <a class="anchor" href="#backstitch-macro">#backstitch-macro</a></h2>
      <p>Threads a value through a sequence of function calls,
        as first parameter for each of them.</p>
      <p>It is an explicit version of what other programming languages
        do to implement member functions, and the result is a usual pattern
        in C libraries.</p>
      <p>Note: the <code>@</code> symbol is not recognized
        when written as <code>\u0040</code>,
        but it gets converted to <code>@</code> in the output.
        This serves to escape it when chaining Cedro with another
        pre-processor that uses it.</p>
      <table>
        <tr>
          <td><code>object @ f(a), g(b);</code></td>
          <td><code>f(object, a);
g(object, b);</code></td>
        </tr><tr>
          <td><code>&amp;object @ f(a), g(b);</code></td>
          <td><code>f(&amp;object, a);
g(&amp;object, b);</code></td>
        </tr><tr>
          <td><code>object.field @ f(a), g(b);</code></td>
          <td><code>f(object.field, a);
g(object.field, b);</code></td>
        </tr><tr>
          <td><code>int x = (object @ f(a), g(b));</code></td>
          <td><code>int x = (f(object, a), g(object, b));</code>
            <p>This is the C <a href="https://en.wikipedia.org/wiki/Comma_operator">comma operator</a>, it’s the same as</p>
            <code>f(object, a); int x = g(object, b);</code></td>
        </tr><tr>
          <td><code>object @prefix_... f(a), g(b);</code></td>
          <td><code>prefix_f(object, a);
prefix_g(object, b);</code></td>
        </tr><tr>
          <td><code>object @..._suffix f(a), g(b);</code></td>
          <td><code>f_suffix(object, a);
g_suffix(object, b);</code></td>
        </tr><tr>
          <td>
<code>graphics_context @<a href="https://github.com/memononen/nanovg">nvg</a>...
    BeginPath(),
    Rect(100,100, 120,30),
    Circle(120,120, 5),
    PathWinding(NVG_HOLE),
    FillColor(nvgRGBA(255,192,0,255)),
    Fill();</code>
          </td><td>
<br/><code>nvgBeginPath(graphics_context);
nvgRect(graphics_context, 100,100, 120,30);
nvgCircle(graphics_context, 120,120, 5);
nvgPathWinding(graphics_context, NVG_HOLE);
nvgFillColor(graphics_context, nvgRGBA(255,192,0,255));
nvgFill(graphics_context);</code>
          </td>
        </tr>
      </table>

      <p>For each comma-separated segment,
      if it starts with any of the tokens
      <code>[</code>,
      <code>++</code>, <code>--</code>, <code>.</code>, <code>-></code>,
      <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code>,
      or there is nothing that looks like a function call,
      the insertion point is the beginning of the segment:</p>

      <table>
        <tr>
          <td><code>number_array @ [3]=44, [2]=11;</code></td>
          <td><code>number_array[3]=44; number_array[2]=11;</code></td>
        </tr>
        <tr>
          <td><code>*number_array++ = @ 1, 2;</code></td>
          <td><code>*number_array++ = 1; *number_array++ = 2;</code></td>
        </tr>
        <tr>
          <td><code>figure_center_point @ .x=44, .y=11;</code></td>
          <td><code>figure_center_point.x=44; figure_center_point.y=11;</code></td>
        </tr>
      </table>

      <p>It is a left-associative operator:</p>

      <table>
        <tr>
          <td><code>object @ f(a) @ g(b);</code></td>
          <td><code>g(f(object, a), b);</code></td>
        </tr><tr>
          <td><code>x @ one() @ two() @ three() @ four();</code></td>
          <td><code>four(three(two(one(x))));</code></td>
        </tr>
      </table>

      <p>The object part can be left empty, which is useful for things like
        adding prefixes or suffixes to enumerations:</p>

      <table>
        <tr>
          <td>
<code>typedef enum {
    @TOKEN_... SPACE, WORD, NUMBER
} TokenType;</code>
          </td>
          <td>
<code>typedef enum {
    TOKEN_SPACE, TOKEN_WORD, TOKEN_NUMBER
} TokenType;</code>
          </td>
        </tr>
      </table>

      <p>The segments part can also be left empty
        to add either a prefix or a suffix to an identifier:</p>
      <table>
        <tr>
          <td><code>Next(reader) @xmlTextReader...;</code></td>
          <td><code>xmlTextReaderNext(reader);</code></td>
        </tr><tr>
          <td><code>get(&amp;vector, index) @..._Byte_vec;</code></td>
          <td><code>get_Byte_vec(&amp;vector, index);</code></td>
        </tr><tr>
          <td><code>// <a href="http://docs.libuv.org/en/v1.x/guide/threads.html#core-thread-operations">http://docs.libuv.org/en/v1.x/guide/threads.html#core-thread-operations</a>
// `hare` and `tortoise` are functions.
int main() {
    int tracklen = 10;
    @uv_thread_...
        t hare_id,
        t tortoise_id,
        create(&hare_id, hare, &tracklen),
        create(&tortoise_id, tortoise, &tracklen),

        join(&hare_id),
        join(&tortoise_id);
    return 0;
}
</code></td>
          <td><br/><code>// <a href="http://docs.libuv.org/en/v1.x/guide/threads.html#core-thread-operations">http://docs.libuv.org/en/v1.x/guide/threads.html#core-thread-operations</a>
// `hare` and `tortoise` are functions.
int main() {
    int tracklen = 10;
    uv_thread_t hare_id;
    uv_thread_t tortoise_id;
    uv_thread_create(&amp;hare_id, hare, &amp;tracklen);
    uv_thread_create(&amp;tortoise_id, tortoise, &amp;tracklen);

    uv_thread_join(&amp;hare_id);
    uv_thread_join(&amp;tortoise_id);
    return 0;
}
</code></td>
        </tr>
      </table>

      <h3 id="backstitch-macro-related-work">Related work <a class="anchor" href="#backstitch-macro-related-work">#…-related-work</a></h3>
      <p>Looking for prior implementations of this idea I’ve found
        <a href="https://github.com/eudoxia0/magma">magma</a> (2014),
        where it is called
        <code><a href="https://github.com/eudoxia0/magma#doto">doto</a></code>.
        It is a macro for the
        <a href="https://github.com/eudoxia0/cmacro">cmacro</a>
        pre-processor
        which has the inconvenient of needing the Common Lisp
        <a href="http://www.sbcl.org/">SBCL</a> compiler
        in addition to the C compiler.</p>
      <p>Functional languages often have a similar operator
        without the ability to thread a same value
        through several functions.
        For instance, the equivalent of <code>f₃(f₂(f₁(x)))</code>:</p>
      <table>
        <tr><th><a href="https://en.wikipedia.org/wiki/Thompson_shell">Shell</a></th><td><code><a href="http://doc.cat-v.org/unix/pipes/">|</a></code></td><td><em>pipe</em> operator</td><td><code>echo x | f₁ | f₂ | f₃</code></td></tr>
        <tr><th><a href="https://www.haskell.org/">Haskell</a></th><td><code><a href="https://downloads.haskell.org/~ghc/9.2.1/docs/html/libraries/base-4.16.0.0/Data-Function.html#v:-38-">&</a></code></td><td><em>reverse application</em> operator</td><td><code>x & f₁ & f₂ & f₃</code></td></tr>
        <tr><th><a href="https://elixir-lang.org/">Elixir</a></th><td><code><a href="https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2">|&gt;</a></code></td><td><em>pipe</em> operator</td><td><code>x |&gt; f₁ |&gt; f₂ |&gt; f₃</code></td></tr>
        <tr><th><a href="https://clojure.org/guides/threading_macros">Clojure</a></th><td><code><a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-%3E">-></a></code></td><td><em>threading</em> macro</td><td><code>(-&gt; x f₁ f₂ f₃)</code></td></tr>
        <tr><th><a>Cedro</a></th><td><code>@</code></td><td><em>backstitch</em> macro</td><td><code>x @ f₁() @ f₂() @ f₃()</code></td></tr>
      </table>
      <p>Ada 2005 introduced a feature called
        <a href="https://www.adaic.org/resources/add_content/standards/05rat/html/Rat-2-3.html">prefixed-view notation</a>
        that is more similar to C++
        as the exact function being called can not be determined without
        knowing which methods are implemented for the object type.</p>
    </section>

    <section id="deferred-resource-release">
      <h2>Deferred resource release: <a class="anchor" href="#deferred-resource-release">#deferred-resource-release</a></h2>
      <p>Moves the clean-up code for a variable to the end of its scope
        including the exit points
        <code>break</code>, <code>continue</code>, <code>goto</code>,
        <code>return</code>.</p>
      <p>In C, resources must be released back to the system explicitly
        once they are no longer needed, which usualy happens quite far
        from the place where they were allocated.
        As time passes and changes accumulate in the program,
        it’s easy to forget releasing them in all cases
        or to attempt releasing a resource twice.</p>
      <p>Other programming languages have mechanisms for automatic
        resource release:
        C++ for instance, uses functions called <em>destructors</em>
        that get run <strong>implicitly</strong>
        when exiting a variable’s scope.</p>
      <p>The programming language Go introduced an <strong>explicit</strong> notation called
        «<a href="https://blog.golang.org/defer-panic-and-recover"><em>defer</em></a>»
        that fits better the style of C.
        The first difference is that in Go,
        all releases happen when exiting the function,
        while with Cedro the releases happen when exiting each block,
        like the destructors in C++ do.</p>
      <p>There are more differences, such as for instance that in Go it
        can be used to modify the return value of the function,
        and that Cedro does not even try to handle
        <code><a href="https://en.cppreference.com/w/c/program/longjmp">longjmp()</a></code>,
        <code><a href="https://en.cppreference.com/w/c/program/exit">exit()</a></code>,
        <code><a href="https://en.cppreference.com/w/c/thread/thrd_exit">thrd_exit()</a></code> etc.
        because it could only apply the deferred actions in the current function, not in any function that called this one. See “<i><a href="https://gustedt.wordpress.com/2020/12/14/a-defer-mechanism-for-c/">A defer mechanism for C</a></i>” (<a href="https://hal.inria.fr/hal-03090771/document">published academic paper as PDF</a> in the <a href="http://www.sigapp.org/sac/sac2021/program.html">SAC’21</a> conference) for a compiler-level implementation that does handle <code>longjmp()</code> and stack unwinding.</p>
      <p>In Cedro, the release function is marked with the
      <a href="https://en.cppreference.com/w/c/language/storage_duration">C keyword <b><code>auto</code></b></a>
      which is not needed in standard C code because it is the default.
      If you want to use Cedro with standard C code that already uses <code>auto</code>,
      you can first replace it with <code>signed</code> as
      <a href="https://stackoverflow.com/a/60890064/291462">it has the same effect</a>.</p>
      <p>In this example, there is a <code>text</code> store and a <code>file</code> that must be released back to the system:</p>
      <table>
        <tr>
          <td>
<code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;

<b>#pragma Cedro 1.0</b>

int repeat_letter(char letter, size_t count,
                  char* file_name)
{
    char* text = malloc(count + 1);
    if (!text) return ENOMEM;
    <b>auto free(text);</b>
    for (size_t i = 0; i &lt; count; ++i) {
        text[i] = letter;
    }
    text[count] = 0;
    if (file_name) {
        FILE* file = fopen(file_name, "w");
        if (!file) return errno;
        <b>auto fclose(file);</b>
        fwrite(text, sizeof(char), count, file);
        fputc('\n', file);
    }
    printf("Repeated %lu times: %s\n",
           count, text);
    return 0;
}

int main(void)
{
    return repeat_letter('A', 6, "aaaaaa.txt");
}</code></td><td>
<br/><br/><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;

int repeat_letter(char letter, size_t count,
                  char* file_name)
{
    char* text = malloc(count + 1);
    if (!text) return ENOMEM;
    for (size_t i = 0; i &lt; count; ++i) {
        text[i] = letter;
    }
    text[count] = 0;
    if (file_name) {
        FILE* file = fopen(file_name, "w");
        if (!file) {
            <b>free(text);</b>
            return errno;
        }
        fwrite(text, sizeof(char), count, file);
        fputc('\n', file);
        <b>fclose(file);</b>
    }
    printf("Repeated %lu times: %s\n",
           count, text);
    <b>free(text);</b>
    return 0;
}

int main(void)
{
    return repeat_letter('A', 6, "aaaaaa.txt");
}</code></td>
        </tr>
      </table>

      <p>Compiling it with GCC or clang,
        on the left running explicitly the compiler,
        and on the right using <code>cedrocc</code>
        which has the same effect:</p>
      <table>
        <tr>
<td><code>$ cedro repeat.c | cc -o repeat -x c -
$ ./repeat
Repeated 6 times: AAAAAA
$ cat aaaaaa.txt
AAAAAA
$ valgrind --leak-check=yes ./repeat
…
==8795== HEAP SUMMARY:
==8795==     in use at exit: 0 bytes in 0 blocks
==8795==   total heap usage: 4 allocs, 4 frees,
                             5,599 bytes allocated
==8795==
==8795== All heap blocks were freed -- no leaks are possible</code>
</td><td>
<code>$ cedrocc -o repeat repeat.c
$ ./repeat
Repeated 6 times: AAAAAA
$ cat aaaaaa.txt
AAAAAA
$ valgrind --leak-check=yes ./repeat
…
==8795== HEAP SUMMARY:
==8795==     in use at exit: 0 bytes in 0 blocks
==8795==   total heap usage: 4 allocs, 4 frees,
                             5,599 bytes allocated
==8795==
==8795== All heap blocks were freed -- no leaks are possible</code>
</td>
        </tr>
      </table>

      <p>In this example adapted from
        <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2542.pdf#40">“Proposal for C2x, WG14 ​n2542, Defer Mechanism for C” p. 40</a>,
        the released resources are spin locks:
        <em>(the difference of course is that in this case the <code>spin_unlock()</code> calls do not run after the panic)</em></p>
      <table>
        <tr>
          <td>
            <code>/* Adapted from example in n2542.pdf#40 */

<b>#pragma Cedro 1.0</b>

int f1(void) {
  puts("g called");
  if (bad1()) { return 1; }
  spin_lock(&amp;lock1);
  <b>auto spin_unlock(&amp;lock1);</b>
  if (bad2()) { return 1; }
  spin_lock(&amp;lock2);
  <b>auto spin_unlock(&amp;lock2);</b>
  if (bad()) { return 1; }

  /* Access data protected by the spinlock then force a panic */
  completed += 1;
  unforced(completed);

  return 0;
}</code>
          </td>
          <td>
            <code>/* Adapted from example in n2542.pdf#40 */

int f1(void) {
  puts("g called");
  if (bad1()) { return 1; }
  spin_lock(&amp;lock1);
  if (bad2()) { <b>spin_unlock(&amp;lock1);</b> return 1; }
  spin_lock(&amp;lock2);
  if (bad()) { <b>spin_unlock(&amp;lock2); spin_unlock(&amp;lock1);</b> return 1; }

  /* Access data protected by the spinlock then force a panic */
  completed += 1;
  unforced(completed);

  <b>spin_unlock(&amp;lock2);</b>
  <b>spin_unlock(&amp;lock1);</b>

  return 0;
}
</code>
          </td>
        </tr>
      </table>

      <p>Andrew Kelley compared resource management between C and his
        <a href="https://ziglang.org/">Zig programming language</a>
        in a 2019 presentation titled
        <a href="https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s">“The Road to Zig 1.0” at 29:21s</a>,
        and here I’ve re-created his C example using Cedro to produce
        the function as he showed it, except that Cedro does not know
        that the final <code>for</code> loop never ends so it adds
        unnecessary resource release code after it.</p>
      <table>
        <tr>
          <td>
            <code>// Example retrofitted from C example by Andrew Kelley:
// <a href="https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s">https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s</a>

#pragma Cedro 1.0

int main(int argc, char **argv) {
    struct SoundIo *soundio = soundio_create();
    if (!soundio) {
        fprintf(stderr, "out of memory\n");
        return 1;
    }
    <b>auto soundio_destroy(soundio);</b>
    int err;
    if ((err = soundio_connect(soundio))) {
        fprintf(stderr, "unable to connect: %s\n", soundio_strerror(err));
        return 1;
    }
    soundio_flush_events(soundio);
    int default_output_index = soundio_default_output_device_index(soundio);
    if (default_output_index < 0) {
        fprintf(stderr, "No output device\n");
        return 1;
    }
    struct SoundIoDevice *device = soundio_get_output_device(soundio, default_output_index);
    if (!device) {
        fprintf(stderr, "out of memory\n");
        return 1;
    }
    <b>auto soundio_device_unref(device);</b>
    struct SoundIoOutStream *outstream = soundio_outstream_create(device);
    if (!outstream) {
        fprintf(stderr, "out of memory\n");
        return 1;
    }
    <b>auto soundio_outstream_destroy(outstream);</b>
    outstream->format = SoundIoFormatFloat32NE;
    outstream->write_callback = write_callback;
    if ((err = soundio_outstream_open(outstream))) {
        fprintf(stderr, "unable to open device: %s" "\n", soundio_strerror(err));
        return 1;
    }
    if ((err = soundio_outstream_start(outstream))) {
        fprintf(stderr, "unable to start device: %s\n", soundio_strerror(err));
        return 1;
    }
    for (;;) soundio_wait_events(soundio);
}</code>
          </td><td>
            <code>// Example retrofitted from C example by Andrew Kelley:
// <a href="https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s">https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s</a>

int main(int argc, char **argv) {
    struct SoundIo *soundio = soundio_create();
    if (!soundio) {
        fprintf(stderr, "out of memory\n");
        return 1;
    }
    int err;
    if ((err = soundio_connect(soundio))) {
        fprintf(stderr, "unable to connect: %s\n", soundio_strerror(err));
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    soundio_flush_events(soundio);
    int default_output_index = soundio_default_output_device_index(soundio);
    if (default_output_index < 0) {
        fprintf(stderr, "No output device\n");
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    struct SoundIoDevice *device = soundio_get_output_device(soundio, default_output_index);
    if (!device) {
        fprintf(stderr, "out of memory\n");
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    struct SoundIoOutStream *outstream = soundio_outstream_create(device);
    if (!outstream) {
        fprintf(stderr, "out of memory\n");
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    outstream->format = SoundIoFormatFloat32NE;
    outstream->write_callback = write_callback;
    if ((err = soundio_outstream_open(outstream))) {
        fprintf(stderr, "unable to open device: %s" "\n", soundio_strerror(err));
        <b>soundio_outstream_destroy(outstream);</b>
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    if ((err = soundio_outstream_start(outstream))) {
        fprintf(stderr, "unable to start device: %s\n", soundio_strerror(err));
        <b>soundio_outstream_destroy(outstream);</b>
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    for (;;) soundio_wait_events(soundio);
    <b>soundio_outstream_destroy(outstream);</b>
    <b>soundio_device_unref(device);</b>
    <b>soundio_destroy(soundio);</b>
}</code>
          </td>
        </tr>
      </table>
      <p>However, his Zig example had the unfair advantage of
        returning error values instead of printing error messages
        which takes more space.
        The following is a C function that
        matches the Zig version more closely:</p>
      <table>
        <tr>
          <td>
            <code>// Example retrofitted from Zig example by Andrew Kelley:
// <a href="https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s">https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s</a>

#pragma Cedro 1.0

int main(int argc, char **argv) {
    struct SoundIo *soundio = soundio_create();
    if (!soundio) { return SoundIoErrorNoMem; }
    <b>auto soundio_destroy(soundio);</b>

    int err;
    if ((err = soundio_connect(soundio))) return err;

    soundio_flush_events(soundio);

    const int default_output_index = soundio_default_output_device_index(soundio);
    if (default_output_index < 0) return SoundIoErrorNoSuchDevice;

    const struct SoundIoDevice *device = soundio_get_output_device(soundio, default_output_index);
    if (!device) return SoundIoErrorNoMem;
    <b>auto soundio_device_unref(device);</b>

    const struct SoundIoOutStream *outstream = soundio_outstream_create(device);
    if (!outstream) return SoundIoErrorNoMem;
    <b>auto soundio_outstream_destroy(outstream);</b>

    outstream->format = SoundIoFormatFloat32NE;
    outstream->write_callback = write_callback;

    if ((err = soundio_outstream_open(outstream))) return err;
    if ((err = soundio_outstream_start(outstream))) return err;

    while (true) soundio_wait_events(soundio);
}</code>
          </td>
          <td>
            <code>// Example retrofitted from Zig example by Andrew Kelley:
// <a href="https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s">https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s</a>

int main(int argc, char **argv) {
    struct SoundIo *soundio = soundio_create();
    if (!soundio) { return SoundIoErrorNoMem; }

    int err;
    if ((err = soundio_connect(soundio))) {
        <b>soundio_destroy(soundio);</b>
        return err;
    }

    soundio_flush_events(soundio);

    const int default_output_index = soundio_default_output_device_index(soundio);
    if (default_output_index < 0) {
        <b>soundio_destroy(soundio);</b>
        return SoundIoErrorNoSuchDevice;
    }

    const struct SoundIoDevice *device = soundio_get_output_device(soundio, default_output_index);
    if (!device) {
        <b>soundio_destroy(soundio);</b>
        return SoundIoErrorNoMem;
    }

    const struct SoundIoOutStream *outstream = soundio_outstream_create(device);
    if (!outstream) {
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return SoundIoErrorNoMem;
    }

    outstream->format = SoundIoFormatFloat32NE;
    outstream->write_callback = write_callback;

    if ((err = soundio_outstream_open(outstream))) {
        <b>soundio_outstream_destroy(outstream);</b>
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return err;
    }
    if ((err = soundio_outstream_start(outstream))) {
        <b>soundio_outstream_destroy(outstream);</b>
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return err;
    }

    while (true) soundio_wait_events(soundio);
    <b>soundio_outstream_destroy(outstream);</b>
    <b>soundio_device_unref(device);</b>
    <b>soundio_destroy(soundio);</b>
}</code>
          </td>
        </tr>
      </table>
      <p>The Cedro version is much closer,
        but his point still stands because the plain C version
        needs a lot of repeated code and is more fragile.
        And of course Zig has
        <a href="https://ziglang.org/learn/overview/">many other great features</a>.</p>

      <h3 id="deferred-resource-release-related-work">Related work <a class="anchor" href="#deferred-resource-release-related-work">#…-related-work</a></h3>
      <p>Apart from the already mentioned
        «<a href="#a-defer-mechanism-for-c"><em>A defer mechanism for C</em></a>»,
        there are macros that use a <code>for</code> loop as
        <code>for (<em>allocation and initialization</em>; <em>condition</em>; <em>release</em>) { <em>actions</em> }</code>
        [<a href="#note-defer-1" name="node-defer-1-ref">1</a>]
        or other techniques
        [<a href="#note-defer-2" name="node-defer-2-ref">2</a>].</p>
      <div id="note-defer-1">
        [<a href="#note-defer-1-ref">1</a>]
        “<em><a href="https://gustedt.gitlabpages.inria.fr/p99/p99-html/utilities.html#blocks">P99 Scope-bound resource management with for-statements</a></em>” from the same author (2010), “<em><a href="https://www.reddit.com/r/C_Programming/comments/46lpna/would_it_be_possible_to_create_a_scoped_lock/">Would it be possible to create a scoped_lock implementation in C?</a></em>” (2016), ”<em><a href="https://news.ycombinator.com/item?id=25419916">C compatible scoped locks</a></em>“ (2021), “<em><a href="https://www.youtube.com/watch?v=QpAhX-gsHMs&amp;t=1053s">Modern C and What We Can Learn From It - Luca Sas [ ACCU 2021 ] 00:17:18</a></em>”, 2021
        <!-- C++: , o “<em><a href="https://stackoverflow.com/questions/48117908/is-the-a-practical-way-to-emulate-go-language-defer-in-c-or-c-destructors">Is there a practical way to emulate GO language defer in C?</a></em>” -->
      </div>
      <div id="note-defer-2">
        [<a href="#note-defer-2-ref">2</a>]
        “<em><a href="https://www.reddit.com/r/C_Programming/comments/46lpna/would_it_be_possible_to_create_a_scoped_lock/">Would it be possible to create a scoped_lock implementation in C?</a></em>” (2016), “<em><a href="https://github.com/trws/libdefer#limitations">libdefer: Go-style defer for C</a></em>” (2016), “<em><a href="https://github.com/moon-chilled/Defer">A Defer statement for C</a></em>” (2020), “<em><a href="https://gist.github.com/jart/aed0fd7a7fa68385d19e76a63db687ff">Go-like defer for C that works with most optimization flag combinations under GCC/Clang</a></em>” (2021)
      </div>
      <p>Compilers like GCC and clang have non-standard features to do this
        like the <a href="https://echorand.me/site/notes/articles/c_cleanup/cleanup_attribute_c.html"><code>__cleanup__</code> variable attribute</a>.</p>
      <p>Cedro does not have the limitation of the deferred code having to be a function: it can be a code block, with or without conditionals, which allows for instance to emulate <a href="https://ziglang.org/learn/overview/#manual-memory-management">Zig’s <code>errdefer</code></a> by performing different actions in case of error:</p>
      <table>
        <tr>
          <td>
            <code>char* allocate_block(size_t n, char** err_p)
{
    char* result = malloc(n);
    <b>auto if (*err_p) {
        free(result);
        result = NULL;
    }</b>

    if (n > 10) {
        *err_p = "n is too big";
    }

    return result;
}</code>
          </td><td>
            <code>char* allocate_block(size_t n, char** err_p)
{
    char* result = malloc(n);

    if (n > 10) {
        *err_p = "n is too big";
    }

    <b>if (*err_p) {
        free(result);
        result = NULL;
    }</b>

    return result;
}</code>
          </td>
        </tr>
      </table>
    </section>

    <section id="block-macros">
      <h2>Block macros: <a class="anchor" href="#block-macros">#block-macros</a></h2>
      <p>Formats a multi-line macro into a single line.</p>
      <p>C macros must be written all in one line,
        but some times you need to split them in several pseudo-lines
        and it gets tedious and error-prone
        to maintain all the newline escapes (<code>\</code>).</p>
      <p>By adding braces (<code>{</code> or <code>}</code>)
        right after <code>#define</code>
        we can have <em>Cedro</em> do that for us:</p>
      <table>
        <tr>
          <td>
            <code>#define { macro(A, B, C)
f_##A(B, C); /// Version of f() for type A.
#define }</code>
          </td><td>
            <code>#define macro(A, B, C)                                            \
f_##A(B, C); /** Version of f() for type A. */                    \
/* End #define */</code>
          </td>
        </tr>
      </table>
      <p>Preprocessor directives are still not allowed
        inside macros, so you can not use
        <code>#if</code>, <code>#include</code>, etc.</p>
      <p>Note: the directive must start exactly with
        <code>#define {</code> or <code>#define }</code>,
        with no more or less space between
        <code>#define</code> and the brace
        <code>{</code> or <code>}</code>.</p>
    </section>

    <section id="loop-macros">
      <h2>Loop macros: <a class="anchor" href="#loop-macros">#loop-macros</a></h2>
      <p>Repeat the lines between
        <code>#foreach { ...</code> y <code>#foreach }</code>
        replacing the given variables.</p>
      <p>As in <code>#define</code>,
        the <code>##</code> serves to
         <a href="https://gcc.gnu.org/onlinedocs/cpp/Concatenation.html#Concatenation">join <em>tokens</em></a>
        so that if, for example,
        <code>T</code> is <code>float</code>,
        <code>Vec_##T</code> produces <code>Vec_float</code>.</p>
      <p>Inside the loop,
        any operator following a <code>#</code>
        (e.g. <code>#,</code>) gets omitted in the last iteration.</p>
      <table>
        <tr>
          <td>
            <code>typedef enum {
#foreach { <b>V</b> {<b>SPACE</b>, <b>NUMBER</b>, \
              <b>KEYWORD</b>, <b>IDENTIFIER</b>, <b>OPERATOR</b>}
  T_##<b>V</b>#,
#foreach }
} TokenType;</code>
          </td><td>
            <code>typedef enum {
  T_<b>SPACE</b>,
  T_<b>NUMBER</b>,
  T_<b>KEYWORD</b>,
  T_<b>IDENTIFIER</b>,
  T_<b>OPERATOR</b>
} TokenType;</code>
          </td>
        </tr>
      </table>

      <p>If a variable has the prefix <code>#</code>,
        <a href="https://gcc.gnu.org/onlinedocs/cpp/Stringizing.html#Stringizing">the result is a string with its contents</a>.
        if <code>T</code> is <code>float</code>,
        <code>char* name = #T;</code> produces
        <code>char* name = <b>"float"</b>;</code>.</p>
      <p>Loops can be nested,
        and the list of values can come from
        a variable defined in an outer loop.</p>
      <table>
        <tr>
          <td>
            <code>#foreach { <b>VALUES</b> {{<b>SPACE</b>, <b>NUMBER</b>, \
                    <b>KEYWORD</b>, <b>IDENTIFIER</b>, <b>OPERATOR</b>}}
typedef enum {
#foreach { <b>V</b> <b>VALUES</b>
  T_##<b>V</b>#,
#foreach }
} TokenType;

const char* const TokenType_STRING[] = {
#foreach { <b>V</b> <b>VALUES</b>
  #<b>V</b>#,
#foreach }
};
#foreach }
</code>
          </td><td>
            <code>typedef enum {
  T_<b>SPACE</b>,
  T_<b>NUMBER</b>,
  T_<b>KEYWORD</b>,
  T_<b>IDENTIFIER</b>,
  T_<b>OPERATOR</b>
} TokenType;

const char* const TokenType_STRING[] = {
  "<b>SPACE</b>",
  "<b>NUMBER</b>",
  "<b>KEYWORD</b>",
  "<b>IDENTIFIER</b>",
  "<b>OPERATOR</b>"
};</code>
          </td>
        </tr>
      </table>

      <p>It is possible to iterate several variables in parallel
        using tuples of variables and values,
        that must have the same number of elements:</p>
      <table>
        <tr>
          <td>
            <code>#foreach { {<b>TYPE</b>, <b>VALUES</b>} {                       \
  { <b>TokenType</b>, {<b>SPACE</b>, <b>NUMBER</b>,                    \
                <b>KEYWORD</b>, <b>IDENTIFIER</b>, <b>OPERATOR</b>} }, \
  { <b>PinConfig</b>, {<b>INPUT</b>, <b>OUTPUT</b>} }                  \
  }
typedef enum {
#foreach { <b>V</b> <b>VALUES</b>
  T_##<b>V</b>#,
#foreach }
} <b>TYPE</b>;

const char* const <b>TYPE</b>##_STRING[] = {
#foreach { <b>V</b> <b>VALUES</b>
  #<b>V</b>#,
#foreach }
};

#foreach }</code>
          </td><td>
            <code>typedef enum {
  T_<b>SPACE</b>,
  T_<b>NUMBER</b>,
  T_<b>KEYWORD</b>,
  T_<b>IDENTIFIER</b>,
  T_<b>OPERATOR</b>
} <b>TokenType</b>;

const char* const <b>TokenType</b>_STRING[] = {
  "<b>SPACE</b>",
  "<b>NUMBER</b>",
  "<b>KEYWORD</b>",
  "<b>IDENTIFIER</b>",
  "<b>OPERATOR</b>"
};

typedef enum {
  T_<b>INPUT</b>,
  T_<b>OUTPUT</b>
} <b>PinConfig</b>;

const char* const <b>PinConfig</b>_STRING[] = {
  "<b>INPUT</b>",
  "<b>OUTPUT</b>"
};

</code>
          </td>
        </tr>
      </table>

      <p>This example iterates over a list of fields
        to build a <code>struct</code>
        and the corresponding <code>print_...()</code> function.</p>
      <table>
        <tr>
          <td>
            <code>void print_double(double n, FILE* out)
{
  fprintf(out, "%f", n);
}

typedef uint32_t Colour_ARGB;
void print_Colour_ARGB(Colour_ARGB c, FILE* out)
{
  fprintf(out, "#%.6X", c);
}

#foreach { <b>FIELDS</b> {{                              \
  { <b>double</b>,   <b>x</b>,         <b>/** X position. */</b>    }, \
  { <b>double</b>,   <b>y</b>,         <b>/** Y position. */</b>    }, \
  { <b>Colour_ARGB</b>, <b>colour</b>, <b>/** Colour 32 bit. */</b> }  \
  }}
typedef struct Point {
#foreach { {<b>TYPE</b>, <b>NAME</b>, <b>COMMENT</b>} <b>FIELDS</b>
  <b>TYPE</b> <b>NAME</b>; <b>COMMENT</b>
#foreach }
} Point;

void print_Point(Point point, FILE* out)
{
#foreach { {<b>TYPE</b>, <b>NAME</b>, <b>COMMENT</b>} <b>FIELDS</b>
  print_##<b>TYPE</b>(point.<b>NAME</b>, out); putc('\n', out);
#foreach }
}
#foreach }
</code>
          </td><td>
            <code>void print_double(double n, FILE* out)
{
  fprintf(out, "%f", n);
}

typedef uint32_t Colour_ARGB;
void print_Colour_ARGB(Colour_ARGB c, FILE* out)
{
  fprintf(out, "#%.6X", c);
}

typedef struct Point {
  <b>double</b> <b>x</b>; <b>/** X position. */</b>
  <b>double</b> <b>y</b>; <b>/** Y position. */</b>
  <b>Colour_ARGB</b> <b>colour</b>; <b>/** Colour 32 bit. */</b>
} Point;

void print_Point(Point point, FILE* out)
{
  print_<b>double</b>(point.<b>x</b>, out); putc('\n', out);
  print_<b>double</b>(point.<b>y</b>, out); putc('\n', out);
  print_<b>Colour_ARGB</b>(point.<b>colour</b>, out); putc('\n', out);
}
</code>
          </td>
        </tr>
      </table>

      <p>This complete example defines variants for the types
        <code>float</code>, <code>str</code>, y <code>cstr</code>
        of an array/vector of variable length
        with a function called «append».
        It then uses C11’s
        <code><a href="https://en.cppreference.com/w/c/language/generic">_Generic</a></code>
        to define a pseudo-<a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">polymorphic</a>
        <code>append()</code> function.</p>
      <table>
        <tr>
          <td>
            <code>#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt; // For memcpy().

typedef struct str { uint8_t* start; uint8_t* end; } str;
typedef char* cstr; // Type names must be single words.

#pragma Cedro 1.0

#foreach { <b>TYPES_LIST</b> {{<b>float</b>, <b>str</b>, <b>cstr</b>}}
#foreach { <b>T</b> <b>TYPES_LIST</b>
/** Vector (resizeable array) type. */
typedef struct {
  <b>T</b>* _;
  size_t len;
  size_t capacity;
} Vec_##<b>T</b>;

/** Append a slice to a vector of elements of this type. */
bool
append_Vec_##<b>T</b>(Vec_##<b>T</b> *v, const <b>T</b> *start, const <b>T</b> *end)
{
  const size_t to_add = (size_t)(end - start);
  if (v-&gt;len + to_add &gt; v-&gt;capacity) {
    const size_t new_capacity = v-&gt;len +
        (to_add &lt; v-&gt;len? v-&gt;len: to_add);
    <b>T</b> * const new_start =
        realloc(v-&gt;_, new_capacity * sizeof(<b>T</b>));
    if (!new_start) return false;
    v-&gt;_        = new_start;
    v-&gt;capacity = new_capacity;
  }
  memcpy(v-&gt;_ + v-&gt;len, start, to_add * sizeof(<b>T</b>));
  v-&gt;len += to_add;

  return true;
}

#foreach }
#foreach { <b>DEFINE</b> {<b>#define</b>} // Keep lines separate.
<b>DEFINE</b> append(VEC, START, END) _Generic((VEC), \
#foreach { <b>T</b> <b>TYPES_LIST</b>
  Vec_##<b>T</b>*: append_Vec_##<b>T</b>#, \
#foreach }
  )(VEC, START, END)
#foreach }
#foreach }

#include &lt;stdio.h&gt;
int main(void)
{
  Vec_cstr words = {0};
  cstr animals[] = { "horse", "cat", "chicken", "dog" };
  cstr plants [] = { "radish", "wheat", "tomato" };
  append(&amp;words, &amp;animals[0], &amp;animals[2]);
  append(&amp;words, &amp;plants[0], &amp;plants[3]);
  append(&amp;words, &amp;animals[2], &amp;animals[4]);
  for (cstr *w = words._, *end = words._ + words.len;
       w != end; ++w) {
    fprintf(stderr, "Word: \"%s\"\n", *w);
  }
  return 0;
}</code>
          </td><td>
            <code>#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt; // For memcpy().

typedef struct str { uint8_t* start; uint8_t* end; } str;
typedef char* cstr; // Type names must be single words.

/** Vector (resizeable array) type. */
typedef struct {
  <b>float</b>* _;
  size_t len;
  size_t capacity;
} Vec_<b>float</b>;

/** Append a slice to a vector of elements of this type. */
bool
append_Vec_<b>float</b>(Vec_<b>float</b> *v, const <b>float</b> *start, const <b>float</b> *end)
{
  const size_t to_add = (size_t)(end - start);
  if (v-&gt;len + to_add &gt; v-&gt;capacity) {
    const size_t new_capacity = v-&gt;len +
        (to_add &lt; v-&gt;len? v-&gt;len: to_add);
    <b>float</b> * const new_start =
        realloc(v-&gt;_, new_capacity * sizeof(<b>float</b>));
    if (!new_start) return false;
    v-&gt;_        = new_start;
    v-&gt;capacity = new_capacity;
  }
  memcpy(v-&gt;_ + v-&gt;len, start, to_add * sizeof(<b>float</b>));
  v-&gt;len += to_add;

  return true;
}

/** Vector (resizeable array) type. */
typedef struct {
  <b>str</b>* _;
  size_t len;
  size_t capacity;
} Vec_<b>str</b>;

/** Append a slice to a vector of elements of this type. */
bool
append_Vec_<b>str</b>(Vec_<b>str</b> *v, const <b>str</b> *start, const <b>str</b> *end)
{
  const size_t to_add = (size_t)(end - start);
  if (v-&gt;len + to_add &gt; v-&gt;capacity) {
    const size_t new_capacity = v-&gt;len +
        (to_add &lt; v-&gt;len? v-&gt;len: to_add);
    <b>str</b> * const new_start =
        realloc(v-&gt;_, new_capacity * sizeof(<b>str</b>));
    if (!new_start) return false;
    v-&gt;_        = new_start;
    v-&gt;capacity = new_capacity;
  }
  memcpy(v-&gt;_ + v-&gt;len, start, to_add * sizeof(<b>str</b>));
  v-&gt;len += to_add;

  return true;
}

/** Vector (resizeable array) type. */
typedef struct {
  <b>cstr</b>* _;
  size_t len;
  size_t capacity;
} Vec_<b>cstr</b>;

/** Append a slice to a vector of elements of this type. */
bool
append_Vec_<b>cstr</b>(Vec_<b>cstr</b> *v, const <b>cstr</b> *start, const <b>cstr</b> *end)
{
  const size_t to_add = (size_t)(end - start);
  if (v-&gt;len + to_add &gt; v-&gt;capacity) {
    const size_t new_capacity = v-&gt;len +
        (to_add &lt; v-&gt;len? v-&gt;len: to_add);
    <b>cstr</b> * const new_start =
        realloc(v-&gt;_, new_capacity * sizeof(<b>cstr</b>));
    if (!new_start) return false;
    v-&gt;_        = new_start;
    v-&gt;capacity = new_capacity;
  }
  memcpy(v-&gt;_ + v-&gt;len, start, to_add * sizeof(<b>cstr</b>));
  v-&gt;len += to_add;

  return true;
}

#define append(VEC, START, END) _Generic((VEC), \
  Vec_<b>float</b>*: append_Vec_<b>float</b>, \
  Vec_<b>str</b>*: append_Vec_<b>str</b>, \
  Vec_<b>cstr</b>*: append_Vec_<b>cstr</b> \
  )(VEC, START, END)

#include &lt;stdio.h&gt;
int main(void)
{
  Vec_cstr words = {0};
  cstr animals[] = { "horse", "cat", "chicken", "dog" };
  cstr plants [] = { "radish", "wheat", "tomato" };
  append(&amp;words, &amp;animals[0], &amp;animals[2]);
  append(&amp;words, &amp;plants[0], &amp;plants[3]);
  append(&amp;words, &amp;animals[2], &amp;animals[4]);
  for (cstr *w = words._, *end = words._ + words.len;
       w != end; ++w) {
    fprintf(stderr, "Word: \"%s\"\n", *w);
  }
  return 0;
}</code>
          </td>
        </tr>
      </table>
    </section>

    <section id="slice-notation">
      <h2>Notation for array slices: <a class="anchor" href="#slice-notation">#slice-notation</a></h2>
      <p>Converts <code><b>array</b>[<b>start</b>..<b>end</b>]</code> into <code>&amp;<b>array</b>[<b>start</b>], &amp;<b>array</b>[<b>end</b>]</code>. The array/pointer value <code>array</code> can be just an identifier or in general an expression which, as it will be evaluated twice, must not have any side effects, just <a href="https://gcc.gnu.org/onlinedocs/gcc-11.2.0/cpp/Duplication-of-Side-Effects.html#Duplication-of-Side-Effects">like standard C preprocessor macros</a>.</p>
      <table>
        <tr>
          <td>
            <code>  append(&amp;words, <b>animals</b>[<b>0</b>..<b>2</b>]);
  append(&amp;words, <b>plants</b>[<b>0</b>..<b>3</b>]);
  append(&amp;words, <b>animals</b>[<b>2</b>..<b>4</b>]);
</code>
          </td><td>
            <code>  append(&amp;words, &amp;<b>animals</b>[<b>0</b>], &amp;<b>animals</b>[<b>2</b>]);
  append(&amp;words, &amp;<b>plants</b>[<b>0</b>], &amp;<b>plants</b>[<b>3</b>]);
  append(&amp;words, &amp;<b>animals</b>[<b>2</b>], &amp;<b>animals</b>[<b>4</b>]);
</code>
          </td>
        </tr>
      </table>

      <p>The end of the slice can have a positive sign to indicate that
        it is a relative position to the start of the slice:
        <code><b>array</b>[<b>start</b>..+<b>end</b>]</code> becomes
        <code>&amp;<b>array</b>[<b>start</b>], &amp;<b>array</b>[<b>start</b>+<b>end</b>]</code>.
        In this case, the advice about double execution of side effects applies to
        <code>start</code> in addition to <code>array</code>.</p>
      <table>
        <tr>
          <td>
            <code>  append(&amp;words, <b>animals</b>[<b>0</b>..<b>+2</b>]);
  append(&amp;words, <b>plants</b>[<b>0</b>..<b>3</b>]);
  append(&amp;words, <b>animals</b>[<b>2</b>..<b>+2</b>]);
</code>
          </td><td>
            <code>  append(&amp;words, &amp;<b>animals</b>[<b>0</b>], &amp;<b>animals</b>[<b>0+2</b>]);
  append(&amp;words, &amp;<b>plants</b>[<b>0</b>], &amp;<b>plants</b>[<b>3</b>]);
  append(&amp;words, &amp;<b>animals</b>[<b>2</b>], &amp;<b>animals</b>[<b>2+2</b>]);
</code>
          </td>
        </tr>
      </table>

      <p>If the slice is composed of more than one token, it will be wrapped in parentheses to make sure it’s correct.</p>
      <table>
        <tr>
          <td>
            <code>  append(&amp;words, <b>(uint8_t*)animals</b>[<b>0</b>..<b>+2</b>]);
  append(&amp;words, <b>(uint8_t*)plants</b>[<b>0</b>..<b>3</b>]);
  append(&amp;words, <b>(uint8_t*)animals</b>[<b>2</b>..<b>+2</b>]);
</code>
          </td><td>
            <code>  append(&amp;words, &amp;<b>((uint8_t*)animals)</b>[<b>0</b>], &amp;<b>((uint8_t*)animals)</b>[<b>0+2</b>]);
  append(&amp;words, &amp;<b>((uint8_t*)plants)</b>[<b>0</b>], &amp;<b>((uint8_t*)plants)</b>[<b>3</b>]);
  append(&amp;words, &amp;<b>((uint8_t*)animals)</b>[<b>2</b>], &amp;<b>((uint8_t*)animals)</b>[<b>2+2</b>]);
</code>
          </td>
        </tr>
      </table>

      <h3 id="slice-notation-related-work">Related work <a class="anchor" href="#slice-notation-related-work">#…-related-work</a></h3>
      <p>The notation <code>[a..b]</code> for array slices was
        <a href="https://en.wikipedia.org/wiki/Array_slicing#1968:_Algol_68">first defined in Algol 68</a>
        where it was an alternative to the primary notation <code>[a:b]</code>, and
        both have been adopted by other languages since then.
        The <code>[a..b]</code> form is used in <a href="https://www.adaic.org/">Ada</a>,
        <a href="https://www.perl.org/">Perl</a>, <a href="https://dlang.org/">D</a>, and
        <a href="https://www.rust-lang.org/">Rust</a>, for example.</p>
    </section>

    <section id="binary-include">
      <h2>Binary inclusion: <a class="anchor" href="#binary-include">#binary-include</a></h2>
      <p>Inserts a file as a byte array.</p>
      <table>
        <tr>
          <td>
            <code>#include &lt;stdint.h&gt;
const uint8_t image
#include {images/cedro-32x32.png}
;</code>
          </td><td>
            <code>#include &lt;stdint.h&gt;
const uint8_t image
[1480] = { /* cedro-32x32.png */
0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,…
0x00,0x00,0x00,0x20,0x00,0x00,0x00,…
⋮
};</code>
          </td>
        </tr>
      </table>
      <p>The file name is relative to the including C file.</p>
      <p>Note: the directive must start exactly with <code>#include {</code>,
        with no more or less space between
        <code>#include</code> and the brace <code>{</code>.</p>
      <h3 id="binary-include-related-work">Related work <a class="anchor" href="#binary-include-related-work">#…-related-work</a></h3>
      <p>This feature is an old idea
        and there are several implementations, for instance
        <a href="https://github.com/ConorOG/xxd">xxd</a>
        (as <code>xxd -i</code>, <a href="http://manpages.ubuntu.com/manpages/bionic/man1/xxd.1.html">man page</a>)
        which I used many years ago and has it since 1994.</p>
      <p>More recently,
        the <code><a href="https://doc.rust-lang.org/std/macro.include_bytes.html">include_bytes!()</a></code> macro
        has been very useful to me in my Rust programs.</p>
    </section>

    <a class="link-to-table-of-contents" href="#">↑ Contents</a>
    <footer>
      The Blue Atlas Cedar tree in the icon is the <a href="https://www.bonsai-nbf.org/collections#America">Silver Phoenix</a> bonsai at the <a href="https://usna.usda.gov/">US National Arboretum</a>.
    </footer>
  </body>
</html>
