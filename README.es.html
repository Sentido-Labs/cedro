<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Extensión del lenguaje de programación C: pre-procesador Cedro</title>
    <style type="text/css">@font-face { font-family: 'sorts_mill_goudyregular'; src: local('OFL Sorts Mill Goudy TT'), url('doc/fonts/GoudyStM-webfont.woff') format('woff'); font-weight: normal; font-style: normal; } html { background:#111; } section, footer { font-family:sans-serif; line-height:1.5; max-width:70em; margin:0.5em auto 0.5em auto; background:#222; color:#c92; text-shadow:0 0.1em 0.1em #000; border:thin solid #222; padding:1em; } section + section, section + footer { margin-top:2em; } section>h2:first-child { margin-top:0; } a, a:visited { color:#99e; text-decoration:none; box-shadow:0 2px 1px -1px #77e; } a.img { box-shadow:none; } a.img > img { vertical-align:bottom; } a>code { border-bottom:none; background-color:transparent; } code { display:inline; vertical-align:baseline; padding:0; background:#111; color:#8d8; border:thin solid #333; border-radius:0.25em; padding:0.25em; font-family:Input, monospace; white-space:pre-wrap; } section > code, td > code { display:inline-block; vertical-align:top; } h1 { font-size:200%; margin:0; background-color:#070707; color:#eee; font-family:sorts_mill_goudyregular, serif; font-weight:normal; } h1::after { clear:both; content:""; display:block; } h1>img { vertical-align:bottom; } h2 { font-size:128%; } h3 { font-size:116%; } h4 { font-size:110%; } h2, h3, h4 { font-family:sans-serif; font-weight:normal; color:#c72; } h1>a.anchor, h2>a.anchor, h3>a.anchor, h4>a.anchor { visibility:hidden; } h1:hover>a.anchor, h2:hover>a.anchor, h3:hover>a.anchor, h4:hover>a.anchor { visibility:visible; } table { border-collapse:collapse; background:inherit; } td { vertical-align:top; border:thin solid #777; padding:0.5em; } p { max-width:50em; text-align:justify; } .language-selector { padding:0.25rem; font-size:1rem; } @media (prefers-color-scheme:light) { html { background:#ddd; } section, footer { background:#eee; color:#111; text-shadow:none; border-color:#aaa; } a, a:visited { color:#11d; box-shadow:0 2px 1px -1px #ccd; } code { background:#f7f7f7; color:#000; border-color:#eee; } h2, h3, h4 { color:#222; } }</style>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
  </head>
  <body>
    <section>
      <h1 style="text-align:center"><span style="float:left"><a href="https://sentido-labs.com/es/biblioteca/" class="img"><img alt="Cedro atlántico azul" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABABAMAAABYR2ztAAAAGFBMVEUAAAAWLxcoYCg5izpCsUNN1U1b9Fp7+3umzZ3RAAAAI2lUWHRBdXRob3IAAAAAAEFsYmVydG8gR29uesOhbGV6IFBhbG9tb8X116oAAAGpSURBVEjH5ZTBdpswEEWBnO4dO+dkawTZxwjsbQwjs66R4ANAow+Ipfn9qq7betUgs+xbcpir0byniaL/UElerOIF9Vl7ORBdinT1IOCVyEnVnJDMxyP1cYudR5D5HJqetuGAjW//oITSveqJ7DGc8G3aGzKOJTUTvcQpGJBmMOgz32Rc9NYgjkWgJS9y6CcFNedZCQorZagMMuRJK9e09vycsRzKhhUlSqyDCKsorXo0NEDBSgWclzCF2ZGsr//nOxZF6zROTuMxMAo+Bxr7UQiUSnLgVbMPCNXGJ9kaPRApIkLddnv8WMXn+beIcwCyvg3jENFYdD+jiUg8ZBLJUUjv4vTmnFGocRLaeBDtnmeboRSisjw/thYt+kghoK3M5+weXK+0kg2HZhvDwXo3kMhcqnHeHGIx+TP1SSifpvco/n7LaXdKZzbQErqxY+uMcYB8+8hqaN0twQlIqB9aLn/OLQXA+6JN+6SlhNUiBICQ3SJEpfwoFt3jTYFHdEE1/F5VzXabOmXw99PXBLw+qN/y2/qa6V/y7wu/JtCdbixyd4wZPfxb+geh0KANiaQN5QAAAABJRU5ErkJggg==" width="64" height="64"/></a> Cedro</span>
        <span class="language-selector">Español, <a href="README.en.html">English</a></span>
        <a style="display:inline-block;float:right;font-size:1rem;padding:0.5em" href="http://sentido-labs.com" class="img"><img alt="Sentido-Labs.com" src="doc/sentido-labs-mono.svg" style="width:5em"/></a>
      </h1>
      <p><em>Cedro</em> es una extensión del lenguaje C que funciona como pre-procesador con cuatro prestaciones:</p>
      <ol>
        <li>El <a href="#backstitch-operator">operador <em>pespunte</em> <code>@</code></a> [«<em>backstitch</em>» <a href="README.en.html">en inglés</a>].</li>
        <li><a href="#deferred-resource-release">Devolución <em>diferida</em> de recursos</a> [«<em>defer</em>»].</li>
        <li><a href="#block-macros"><em>Macros de bloque</em></a>.</li>
        <li><a href="#binary-include"><em>Inclusión binaria</em></a>.</li>
      </ol>
      <p>Para activarlo, el fichero fuente debe contener esta línea:
        <code>#pragma Cedro 1.0</code><br/>
        Si no, el fichero se copia directamente a la salida.</p>
      <code>Uso: cedro [opciones] fichero.c [fichero2.c … ]
  El resultado va a stdout, puede usarse sin fichero intermedio así:
 cedro fichero.c | cc -x c - -o fichero
  Es lo que hace el programa cedrocc:
 cedrocc -o fichero fichero.c
  Con cedrocc, las siguientes opciones son implícitas:
    --discard-comments --insert-line-directives

  --apply-macros     Aplica las macros: pespunte, diferido, etc. (implícito)
  --escape-ucn       Encapsula los caracteres no-ASCII en identificadores.
  --no-apply-macros  No aplica las macros.
  --no-escape-ucn    No encapsula caracteres en identificadores. (implícito)
  --discard-comments    Descarta los comentarios.
  --discard-space       Descarta los espacios en blanco.
  --no-discard-comments No descarta los comentarios. (implícito)
  --no-discard-space    No descarta los espacios.    (implícito)
  --insert-line-directives    Inserta directivas #line.
  --no-insert-line-directives No inserta directivas #line. (implícito)

  --print-markers    Imprime los marcadores.
  --no-print-markers No imprime los marcadores. (implícito)
  --enable-core-dump    Activa el volcado de memoria al estrellarse.
  --no-enable-core-dump No activa el volcado de memoria al estrellarse. (implícito)
  --benchmark        Realiza una medición de rendimiento.
  --version          Muestra la versión: 1.0
                     El «pragma» correspondiente es: #pragma Cedro 1.0</code>
      <p>La opción <code>--escape-ucn</code> encapsula los caracteres Unicode®
        fuera del intervalo ASCII, cuando forman parte de un identificador,
        como nombres de caracteres universales C99
        («C99 standard», página 65, «<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf#65">6.4.3 Universal character names</a>»),
        lo que puede servir para compiladores más antiguos sin capacidad UTF-8 como
        <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67224#c32">GCC antes de la versión 10</a>.</p>
      <p>Para la documentación (en inglés) de la API, véase <a href="doc/api/index.html">doc/api/index.html</a>
        tras ejecutar <code>make doc</code> que necesita tener
        <a href="https://www.doxygen.nl/index.html">Doxygen</a> instalado.</p>
      <p>El segundo ejecutable, <code>cedrocc</code>, permite usar Cedro como si fuera parte del compilador C.</p>
      <code>Uso: cedrocc [opciones] &lt;fichero.c&gt; [ fichero2.o … ]
  Ejecuta Cedro en el primer nombre de fichero que acabe en «.c»,
  y compila el resultado con «cc -x c -» mas los otros argumentos.
    cedrocc -o fichero fichero.c
    cedro fichero.c | cc -x c - -o fichero
  Se puede especificar el compilador, p.ej. gcc:
    CEDRO_CC='gcc -x c -' cedrocc …
  Para depuración, esto escribe el código que iría entubado a cc,
  en stdout:
    CEDRO_CC='' cedrocc …</code>
      <p>Hay un tercer ejecutable, <code>cedro-new</code>, que produce un borrador de programa de manera similar a <code>cargo new</code> en Rust. <code>cedro new …</code> en realidad ejecuta <code>cedro-new …</code>. El contenido se produce a partir de la plantilla en el directorio <code>template/</code>, que se incluye en el ejecutable <code>cedro-new</code> al compilarlo.</p>
      <code>Uso: cedro-new [opciones] &lt;nombre&gt;
  Crea un directorio llamado &lt;nombre&gt;/ con la plantilla.
  -h, --help        Muestra este mensaje.
  -i, --interactive Pregunta por los nombres de programa y proyecto.
                    Si no, se eligen a partir del nombre del directorio.</code>
    </section>

    <section id="backstitch-operator">
      <h2>Operador <a href="https://es.wikipedia.org/wiki/Pespunte">pespunte</a>: @ <a class="anchor" href="#backstitch-operator">#backstitch-operator</a></h2>
      <p>Hilvana un valor a través de una secuencia de llamadas de función,
        como primer parámetro para cada una.</p>
      <p>Es una versión explícita de lo que hacen otros lenguajes de programación
        para implementar funciones miembro, y el resultado es un patrón habitual
        en bibliotecas en C.</p>
      <table>
        <tr>
          <td><code>objeto @ f(a), g(b);</code></td>
          <td><code>f(objeto, a);
g(objeto, b);</code></td>
        </tr><tr>
          <td><code>&amp;objeto @ f(a), g(b);</code></td>
          <td><code>f(&amp;objeto, a);
g(&amp;objeto, b);</code></td>
        </tr><tr>
          <td><code>objeto.casilla @ f(a), g(b);</code></td>
          <td><code>f(objeto.casilla, a);
g(objeto.casilla, b);</code></td>
        </tr><tr>
          <td><code>int x = (objeto @ f(a), g(b));</code></td>
          <td><code>int x = (f(objeto, a), g(objeto, b));</code>
            <p>Esto es el <a href="https://en.wikipedia.org/wiki/Comma_operator">operador coma</a> del C, lo mismo que</p>
            <code>f(objeto, a); int x = g(objeto, b);</code></td>
        </tr><tr>
          <td><code>objeto @prefijo_... f(a), g(b);</code></td>
          <td><code>prefijo_f(objeto, a);
prefijo_g(objeto, b);</code></td>
        </tr><tr>
          <td><code>objeto @..._sufijo f(a), g(b);</code></td>
          <td><code>f_sufijo(objeto, a);
g_sufijo(objeto, b);</code></td>
        </tr><tr>
          <td>
<code>contexto_gráfico @<a href="https://github.com/memononen/nanovg">nvg</a>...
    BeginPath(),
    Rect(100,100, 120,30),
    Circle(120,120, 5),
    PathWinding(NVG_HOLE),
    FillColor(nvgRGBA(255,192,0,255)),
    Fill();</code>
          </td><td>
<br/><code>nvgBeginPath(contexto_gráfico);
nvgRect(contexto_gráfico, 100,100, 120,30);
nvgCircle(contexto_gráfico, 120,120, 5);
nvgPathWinding(contexto_gráfico, NVG_HOLE);
nvgFillColor(contexto_gráfico, nvgRGBA(255,192,0,255));
nvgFill(contexto_gráfico);</code>
          </td>
        </tr>
      </table>

      <p>Para cada segmento separado por comas,
      si empieza con uno de los <em>tókens</em>
      “<code>[</code>”,
      “<code>++</code>”, “<code>--</code>”, “<code>.</code>”, “<code>-></code>”,
      “<code>=</code>”, “<code>+=</code>”, “<code>-=</code>”, “<code>*=</code>”, “<code>/=</code>”, “<code>%=</code>”, “<code>&lt;&lt;=</code>”, “<code>&gt;&gt;=</code>”, “<code>&amp;=</code>”, “<code>^=</code>”, “<code>|=</code>”,
      o si no hay nada que parezca una llamada de función,
      el punto de inserción es el comienzo del segmento:</p>

      <table>
        <tr>
          <td><code>ristra_de_números @ [3]=44, [2]=11;</code></td>
          <td><code>ristra_de_números[3]=44; ristra_de_números[2]=11;</code></td>
        </tr>
        <tr>
          <td><code>*ristra_de_números++ = @ 1, 2;</code></td>
          <td><code>*ristra_de_números++ = 1; *ristra_de_números++ = 2;</code></td>
        </tr>
        <tr>
          <td><code>punto_central_de_figura @ .x=44, .y=11;</code></td>
          <td><code>punto_central_de_figura.x=44; punto_central_de_figura.y=11;</code></td>
        </tr>
      </table>

      <p>La parte de objeto se puede omitir, lo que sirve por ejemplo
        para añadir prefijos o sufijos a enumeraciones:</p>

      <table>
        <tr>
          <td>
<code>typedef enum {
    @TOKEN_... ESPACIO, PALABRA, NUMERO
} TipoDeToken;</code>
          </td>
          <td>
<code>typedef enum {
    TOKEN_ESPACIO, TOKEN_PALABRA, TOKEN_NUMERO
} TipoDeToken;</code>
          </td>
        </tr>
      </table>

      <p>Nota: el símbolo <code>@</code> no se reconoce
        cuando se escribe <code>\u0040</code>,
        pero se convierte en <code>@</code> en la salida.
        Esto se puede usar para encapsularlo al encadenar Cedro con otro
        pre-procesador que lo use.</p>

      <h3 id="backstitch-operator-related-work">Obras relacionadas <a class="anchor" href="#backstitch-operator-related-work">#…-related-work</a></h3>
      <p>Buscando realizaciones anteriores de esta idea he encontrado
        <a href="https://github.com/eudoxia0/magma">magma</a> (2014),
        donde se llama
        <a href="https://github.com/eudoxia0/magma#doto"><code>doto</code></a>.
        Es una macro para el pre-procesador
        <a href="https://github.com/eudoxia0/cmacro">cmacro</a>
        que tiene el inconveniente de necesitar el compilador Common Lisp
        <a href="http://www.sbcl.org/">SBCL</a>.</p>
      <p>Los lenguajes funcionales suelen tener un operador similar aunque
        hilvana el <em>resultado</em> de la primera función
        como primer parámetro de la siguiente etc.
        en vez del mismo valor para todas las funciones.
        Por ejemplo, el equivalente de <code>f₃(f₂(f₁(x)))</code>:</p>
      <ul>
        <li><a href="https://es.wikipedia.org/wiki/Thompson_shell">Shell</a>: operador <a href="http://doc.cat-v.org/unix/pipes/"><code>|</code></a> (tubería), <code>echo x | f₁ | f₂ | f₃</code></li>
        <li><a href="https://www.haskell.org/">Haskell</a>: operador <a href="https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.15.0.0/Data-Function.html#v:-38-"><code>&</code></a> (aplicación inversa), <code>x & f₁ & f₂ & f₃</code></li>
        <li><a href="https://elixir-lang.org/">Elixir</a>: operador <a href="https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2"><code>|&gt;</code></a> (tubería), <code>x |&gt; f₁ |&gt; f₂ |&gt; f₃</code>
        <li><a href="https://clojure.org/guides/threading_macros">Clojure</a>: macro <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-%3E"><code>-&gt;</code></a> (hilvanado), <code>(-&gt; x f₁ f₂ f₃)</code></li>
      </ul>
      <p>Ada 2005 introdujo una prestación llamada
        <a href="https://www.adaic.org/resources/add_content/standards/05rat/html/Rat-2-3.html">notación prefija [«prefixed-view notation»]</a>
        que es más parecida al C++
        ya que la función exacta que se ejecuta no se puede determinar sin
        conocer qué métodos están implementados para el tipo de objeto.</p>
    </section>

    <section id="deferred-resource-release">
      <h2>Devolución diferida de recursos: <a class="anchor" href="#deferred-resource-release">#deferred-resource-release</a></h2>
      <p>Mueve el código de devolución de una variable al final de su alcance,
        incluídos los puntos de salida
        <code>break</code>, <code>continue</code>, <code>goto</code>,
        <code>return</code>.</p>
      <p>En C, los recursos deben devolverse al sistema explícitamente
        una vez no son necesarios, lo que generalmente ocurre bastante lejos
        de la parte donde se reservaron.
        Al pasar el tiempo y acumularse cambios en el programa,
        es fácil olvidar devolverlos en todos los casos
        o intentar devolver un recurso dos veces.</p>
      <p>Otros lenguages de programación tienen mecanismos para devolución
        automática de recursos:
        C++ por ejemplo, usa funciones llamadas <em>destructores</em>
        que se ejecutan de manera <strong>implícita</strong>
        al salir del alcance de una variable.</p>
      <p>El lenguaje Go introdujo una notación <strong>explícita</strong> llamada
        «<a href="https://blog.golang.org/defer-panic-and-recover"><em>defer</em></a>»
        que pega mejor con el estilo del C.
        La primera diferencia es que en Go,
        todas las devoluciones ocurren al salir de la función,
        mientras que con Cedro las devoluciones ocurren al salir de cada bloque,
        como hacen los destructores en C++.</p>
      <p>Hay más diferencias, como por ejemplo que en Go se puede usar para
        modificar el valor de retorno de la función,
        y que Cedro ni siquiera intenta tratar con
        <code><a href="https://en.cppreference.com/w/c/program/longjmp">longjmp()</a></code>,
        <code><a href="https://en.cppreference.com/w/c/program/exit">exit()</a></code>,
        <code><a href="https://en.cppreference.com/w/c/thread/thrd_exit">thrd_exit()</a></code> etc.
        porque sólo podría aplicar las acciones diferidas en la función actual, no en otras functiones que llamaran a ésta. Véase “<i id="a-defer-mechanism-for-c"><a href="https://gustedt.wordpress.com/2020/12/14/a-defer-mechanism-for-c/">A defer mechanism for C</a></i>” (<a href="https://hal.inria.fr/hal-03090771/document">artículo académico publicado como PDF</a> en la conferencia <a href="http://www.sigapp.org/sac/sac2021/program.html">SAC’21</a>) para una implementación a nivel de compilador que efectivamente trata con el <code>longjmp()</code> y con el desenrollado de la pila [«<em>stack unwinding</em>»].</p>
      <p>En Cedro, la función de devolución se marca con la
      <a href="https://en.cppreference.com/w/c/language/storage_duration">palabra clave C <b><code>auto</code></b></a>
      que no se necesita en código estándar C porque es implícita.
      Si quiere usar Cedro con código estándar C que ya usa <code>auto</code>,
      puede primero reemplazarla con <code>signed</code> ya que
      <a href="https://stackoverflow.com/a/60890064/291462">tiene el mismo efecto</a>.</p>
      <p>En este ejemplo, hay un depósito de <code>texto</code> y un <code>fichero</code> que deben ser devueltos al sistema:</p>
      <table>
        <tr>
          <td>
<code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;

<b>#pragma Cedro 1.0</b>

int repite_letra(char letra, size_t cuenta,
                 char* nombre_de_fichero)
{
    char* texto = malloc(cuenta + 1);
    if (!texto) return ENOMEM;
    <b>auto free(texto);</b>
    for (size_t i = 0; i &lt; cuenta; ++i) {
        texto[i] = letra;
    }
    texto[cuenta] = 0;
    if (nombre_de_fichero) {
        FILE* fichero = fopen(nombre_de_fichero, "w");
        if (!fichero) return errno;
        <b>auto fclose(fichero);</b>
        fwrite(texto, sizeof(char), cuenta, fichero);
        fputc('\n', file);
    }
    printf("Repetido %lu veces: %s\n",
           cuenta, texto);
    return 0;
}

int main(void)
{
    return repite_letra('A', 6, "aaaaaa.txt");
}</code></td><td>
<br/><br/><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;

int repite_letra(char letra, size_t cuenta,
                 char* nombre_de_fichero)
{
    char* texto = malloc(cuenta + 1);
    if (!texto) return ENOMEM;
    for (size_t i = 0; i &lt; cuenta; ++i) {
        texto[i] = letra;
    }
    text[cuenta] = 0;
    if (nombre_de_fichero) {
        FILE* fichero = fopen(nombre_de_fichero, "w");
        if (!fichero) {
            <b>free(texto);</b>
            return errno;
        }
        fwrite(texto, sizeof(char), cuenta, fichero);
        fputc('\n', file);
        <b>fclose(fichero);</b>
    }
    printf("Repetido %lu veces: %s\n",
           cuenta, texto);
    <b>free(texto);</b>
    return 0;
}

int main(void)
{
    return repite_letra('A', 6, "aaaaaa.txt");
}</code></td>
        </tr>
      </table>

      <p>Compilación con GCC or clang,
        a la izquierda ejecutando explícitamente el compilador,
        y a la derecha usando <code>cedrocc</code>
        que tiene el mismo efecto:</p>
      <table>
        <tr>
<td><code>$ cedro repite.c | cc -o repite -x c -
$ ./repite
Repeated 6 times: AAAAAA
$ cat aaaaaa.txt
AAAAAA
$ valgrind --leak-check=yes ./repeat
…
==8795== HEAP SUMMARY:
==8795==     in use at exit: 0 bytes in 0 blocks
==8795==   total heap usage: 4 allocs, 4 frees,
                             5,599 bytes allocated
==8795==
==8795== All heap blocks were freed -- no leaks are possible</code>
</td><td>
<code>$ cedrocc -o repite repite.c
$ ./repite
Repeated 6 times: AAAAAA
$ cat aaaaaa.txt
AAAAAA
$ valgrind --leak-check=yes ./repeat
…
==8795== HEAP SUMMARY:
==8795==     in use at exit: 0 bytes in 0 blocks
==8795==   total heap usage: 4 allocs, 4 frees,
                             5,599 bytes allocated
==8795==
==8795== All heap blocks were freed -- no leaks are possible</code>
</td>
        </tr>
      </table>

      <p>En este ejemplo adaptado de
        <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2542.pdf#40">«Proposal for C2x, WG14 ​n2542, Defer Mechanism for C» pág. 40</a>,
        los recursos devueltos son bloqueos giratorios [«spin locks»]:
        <em>(la diferencia por supuesto es que en este caso las llamadas a <code>spin_unlock()</code> no se ejecutan tras el «panic»)</em></p>
      <table>
        <tr>
          <td>
            <code>/* Adapted from example in n2542.pdf#40 */

<b>#pragma Cedro 1.0</b>

int f1(void) {
  puts("g called");
  if (bad1()) { return 1; }
  spin_lock(&amp;lock1);
  <b>auto spin_unlock(&amp;lock1);</b>
  if (bad2()) { return 1; }
  spin_lock(&amp;lock2);
  <b>auto spin_unlock(&amp;lock2);</b>
  if (bad()) { return 1; }

  /* Access data protected by the spinlock then force a panic */
  completed += 1;
  unforced(completed);

  return 0;
}</code>
          </td>
          <td>
            <code>/* Adapted from example in n2542.pdf#40 */

int f1(void) {
  puts("g called");
  if (bad1()) { return 1; }
  spin_lock(&amp;lock1);
  if (bad2()) { <b>spin_unlock(&amp;lock1);</b> return 1; }
  spin_lock(&amp;lock2);
  if (bad()) { <b>spin_unlock(&amp;lock2); spin_unlock(&amp;lock1);</b> return 1; }

  /* Access data protected by the spinlock then force a panic */
  completed += 1;
  unforced(completed);

  <b>spin_unlock(&amp;lock2);</b>
  <b>spin_unlock(&amp;lock1);</b>

  return 0;
}
</code>
          </td>
        </tr>
      </table>

      <h3 id="deferred-resource-release-related-work">Obras relacionadas <a class="anchor" href="#deferred-resource-release-related-work">#…-related-work</a></h3>

      <p>Andrew Kelley comparó la gestión de recursos entre C y su
        <a href="https://ziglang.org/es/">lenguaje de programación Zig</a>
        en una presentación de 2019 titulada
        <a href="https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s">“The Road to Zig 1.0" a los 29:21″</a>,
        y aquí he re-creado su ejemplo en C usando Cedro para producir
        la función tal cual la mostró, excepto que Cedro no sabe
        que el bucle <code>for</code> al final nunca termina así que añade
        devoluciones innecesarias de recursos tras él.</p>
      <table>
        <tr>
          <td>
            <code>// Example retrofitted from C example by Andrew Kelley:
// <a href="https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s">https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s</a>

#pragma Cedro 1.0

int main(int argc, char **argv) {
    struct SoundIo *soundio = soundio_create();
    if (!soundio) {
        fprintf(stderr, "out of memory\n");
        return 1;
    }
    <b>auto soundio_destroy(soundio);</b>
    int err;
    if ((err = soundio_connect(soundio))) {
        fprintf(stderr, "unable to connect: %s\n", soundio_strerror(err));
        return 1;
    }
    soundio_flush_events(soundio);
    int default_output_index = soundio_default_output_device_index(soundio);
    if (default_output_index < 0) {
        fprintf(stderr, "No output device\n");
        return 1;
    }
    struct SoundIoDevice *device = soundio_get_output_device(soundio, default_output_index);
    if (!device) {
        fprintf(stderr, "out of memory\n");
        return 1;
    }
    <b>auto soundio_device_unref(device);</b>
    struct SoundIoOutStream *outstream = soundio_outstream_create(device);
    if (!outstream) {
        fprintf(stderr, "out of memory\n");
        return 1;
    }
    <b>auto soundio_outstream_destroy(outstream);</b>
    outstream->format = SoundIoFormatFloat32NE;
    outstream->write_callback = write_callback;
    if ((err = soundio_outstream_open(outstream))) {
        fprintf(stderr, "unable to open device: %s" "\n", soundio_strerror(err));
        return 1;
    }
    if ((err = soundio_outstream_start(outstream))) {
        fprintf(stderr, "unable to start device: %s\n", soundio_strerror(err));
        return 1;
    }
    for (;;) soundio_wait_events(soundio);
}</code>
          </td><td>
            <code>// Example retrofitted from C example by Andrew Kelley:
// <a href="https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s">https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s</a>

int main(int argc, char **argv) {
    struct SoundIo *soundio = soundio_create();
    if (!soundio) {
        fprintf(stderr, "out of memory\n");
        return 1;
    }
    int err;
    if ((err = soundio_connect(soundio))) {
        fprintf(stderr, "unable to connect: %s\n", soundio_strerror(err));
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    soundio_flush_events(soundio);
    int default_output_index = soundio_default_output_device_index(soundio);
    if (default_output_index < 0) {
        fprintf(stderr, "No output device\n");
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    struct SoundIoDevice *device = soundio_get_output_device(soundio, default_output_index);
    if (!device) {
        fprintf(stderr, "out of memory\n");
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    struct SoundIoOutStream *outstream = soundio_outstream_create(device);
    if (!outstream) {
        fprintf(stderr, "out of memory\n");
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    outstream->format = SoundIoFormatFloat32NE;
    outstream->write_callback = write_callback;
    if ((err = soundio_outstream_open(outstream))) {
        fprintf(stderr, "unable to open device: %s" "\n", soundio_strerror(err));
        <b>soundio_outstream_destroy(outstream);</b>
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    if ((err = soundio_outstream_start(outstream))) {
        fprintf(stderr, "unable to start device: %s\n", soundio_strerror(err));
        <b>soundio_outstream_destroy(outstream);</b>
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return 1;
    }
    for (;;) soundio_wait_events(soundio);
    <b>soundio_outstream_destroy(outstream);</b>
    <b>soundio_device_unref(device);</b>
    <b>soundio_destroy(soundio);</b>
}</code>
          </td>
        </tr>
      </table>
      <p>Sin embargo, su ejemplo en Zig tuvo la ventaja injusta de
        devolver códigos de error en vez de imprimir los mensajes
        lo cual ocupa más espacio.
        Lo siguiente es una función en C que
        se ajusta más a la versión en Zig:</p>
      <table>
        <tr>
          <td>
            <code>// Example retrofitted from Zig example by Andrew Kelley:
// <a href="https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s">https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s</a>

#pragma Cedro 1.0

int main(int argc, char **argv) {
    struct SoundIo *soundio = soundio_create();
    if (!soundio) { return SoundIoErrorNoMem; }
    <b>auto soundio_destroy(soundio);</b>

    int err;
    if ((err = soundio_connect(soundio))) return err;

    soundio_flush_events(soundio);

    const int default_output_index = soundio_default_output_device_index(soundio);
    if (default_output_index < 0) return SoundIoErrorNoSuchDevice;

    const struct SoundIoDevice *device = soundio_get_output_device(soundio, default_output_index);
    if (!device) return SoundIoErrorNoMem;
    <b>auto soundio_device_unref(device);</b>

    const struct SoundIoOutStream *outstream = soundio_outstream_create(device);
    if (!outstream) return SoundIoErrorNoMem;
    <b>auto soundio_outstream_destroy(outstream);</b>

    outstream->format = SoundIoFormatFloat32NE;
    outstream->write_callback = write_callback;

    if ((err = soundio_outstream_open(outstream))) return err;
    if ((err = soundio_outstream_start(outstream))) return err;

    while (true) soundio_wait_events(soundio);
}</code>
          </td>
          <td>
            <code>// Example retrofitted from Zig example by Andrew Kelley:
// <a href="https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s">https://www.youtube.com/watch?v=Gv2I7qTux7g&amp;t=1761s</a>

int main(int argc, char **argv) {
    struct SoundIo *soundio = soundio_create();
    if (!soundio) { return SoundIoErrorNoMem; }

    int err;
    if ((err = soundio_connect(soundio))) {
        <b>soundio_destroy(soundio);</b>
        return err;
    }

    soundio_flush_events(soundio);

    const int default_output_index = soundio_default_output_device_index(soundio);
    if (default_output_index < 0) {
        <b>soundio_destroy(soundio);</b>
        return SoundIoErrorNoSuchDevice;
    }

    const struct SoundIoDevice *device = soundio_get_output_device(soundio, default_output_index);
    if (!device) {
        <b>soundio_destroy(soundio);</b>
        return SoundIoErrorNoMem;
    }

    const struct SoundIoOutStream *outstream = soundio_outstream_create(device);
    if (!outstream) {
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return SoundIoErrorNoMem;
    }

    outstream->format = SoundIoFormatFloat32NE;
    outstream->write_callback = write_callback;

    if ((err = soundio_outstream_open(outstream))) {
        <b>soundio_outstream_destroy(outstream);</b>
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return err;
    }
    if ((err = soundio_outstream_start(outstream))) {
        <b>soundio_outstream_destroy(outstream);</b>
        <b>soundio_device_unref(device);</b>
        <b>soundio_destroy(soundio);</b>
        return err;
    }

    while (true) soundio_wait_events(soundio);
    <b>soundio_outstream_destroy(outstream);</b>
    <b>soundio_device_unref(device);</b>
    <b>soundio_destroy(soundio);</b>
}</code>
          </td>
        </tr>
      </table>
      <p>La versión con Cedro se acerca mucho más,
        pero su argumento se mantiene porque la versión en C puro
        necesita mucho código repetido y es más frágil.
        Y por supuesto Zig tiene
        <a href="https://ziglang.org/es/learn/overview/">muchas otras prestaciones estupendas</a>.</p>

      <p>Aparte de la ya mencionada
        «<a href="#a-defer-mechanism-for-c"><em>A defer mechanism for C</em></a>»,
        hay macros que usan un bucle <code>for</code> como
        <code>for (<em>reserva e inicialización</em>; <em>condición</em>; <em>devolución</em>) { <em>acciones</em> }</code>
        [<a href="#note-defer-1" name="node-defer-1-ref">1</a>]
        u otras técnicas
        [<a href="#note-defer-2" name="node-defer-2-ref">2</a>].</p>
      <div id="note-defer-1">
        [<a href="#note-defer-1-ref">1</a>]
        “<em><a href="https://gustedt.gitlabpages.inria.fr/p99/p99-html/utilities.html#blocks">P99 Scope-bound resource management with for-statements</a></em>” del mismo autor (2010), “<em><a href="https://www.reddit.com/r/C_Programming/comments/46lpna/would_it_be_possible_to_create_a_scoped_lock/">Would it be possible to create a scoped_lock implementation in C?</a></em>” (2016), ”<em><a href="https://news.ycombinator.com/item?id=25419916">C compatible scoped locks</a></em>“ (2021), “<em><a href="https://www.youtube.com/watch?v=QpAhX-gsHMs&amp;t=1053s">Modern C and What We Can Learn From It - Luca Sas [ ACCU 2021 ] 00:17:18</a></em>”, 2021
        <!-- C++: , o “<em><a href="https://stackoverflow.com/questions/48117908/is-the-a-practical-way-to-emulate-go-language-defer-in-c-or-c-destructors">Is there a practical way to emulate GO language defer in C?</a></em>” -->
      </div>
      <div id="note-defer-2">
        [<a href="#note-defer-1-ref">2</a>]
        “<em><a href="https://www.reddit.com/r/C_Programming/comments/46lpna/would_it_be_possible_to_create_a_scoped_lock/">Would it be possible to create a scoped_lock implementation in C?</a></em>” (2016), “<em><a href="https://github.com/trws/libdefer#limitations">libdefer: Go-style defer for C</a></em>” (2016), “<em><a href="https://github.com/moon-chilled/Defer">A Defer statement for C</a></em>” (2020), “<em><a href="https://gist.github.com/jart/aed0fd7a7fa68385d19e76a63db687ff">Go-like defer for C that works with most optimization flag combinations under GCC/Clang</a></em>” (2021)
      </div>
      <p>Compiladores como GCC y clang tienen características no estandarizadas para hacerlo,
        como el <a href="https://echorand.me/site/notes/articles/c_cleanup/cleanup_attribute_c.html">atributo de variables <code>__cleanup__</code> (en inglés)</a>.</p>
      <p>Cedro no tiene la limitación de que el código diferido tenga que ser una función: puede ser un bloque de código, con o sin condicionales, lo que permite por ejemplo emular el <a href="https://ziglang.org/learn/overview/#manual-memory-management"><code>errdefer</code> de Zig</a> realizando acciones diferentes en caso de error:</p>
      <table>
        <tr>
          <td>
            <code>char* reserva_bloque(size_t n, char** err_p)
{
    char* resultado = malloc(n);
    <b>auto if (*err_p) {
        free(resultado);
        resultado = NULL;
    }</b>

    if (n > 10) {
        *err_p = "n es demasiado grande";
    }

    return resultado;
}</code>
          </td><td>
            <code>char* reserva_bloque(size_t n, char** err_p)
{
    char* resultado = malloc(n);

    if (n > 10) {
        *err_p = "n es demasiado grande";
    }

    <b>if (*err_p) {
        free(resultado);
        resultado = NULL;
    }</b>

    return resultado;
}</code>
          </td>
        </tr>
      </table>
    </section>

    <section ="block-macros">
      <h2>Macros de bloque: <a class="anchor" href="#block-macros">#block-macros</a></h2>
      <p>Formatea una macro multi-línea en una sóla línea.</p>
      <p>Las macros en C deben escribirse todo en una línea,
        pero a veces hay que partirlas en varias pseudo-líneas
        y se hace tedioso y propenso a errores
        el mantener todos los escapes de nueva línea  (“<code>\</code>”).</p>
      <p>Añadiendo llaves (“<code>{</code>” o “<code>}</code>”)
        justo tras <code>#define</code>
        podemos hacer que <em>Cedro</em> se encargue de eso por nosotros:</p>
<code>#define { macro(A, B, C)
f_##A(B, C); /// Versión especializada de f() para el tipo A.
#define }</code>
<code>#define macro(A, B, C)                                                        \
f_##A(B, C); /** Versión especializada de f() para el tipo A. */              \
/* End #define */</code>
      <p>Aún así, las directrices de preprocesador no se permiten
        dentro de macros, de manera que no se pueden usar
        <code>#if</code>, <code>#include</code>, etc.</p>
      <p>Nota: la directiva debe empezar exactamente con
        «<code>#define {</code>» o «<code>#define }</code>»,
        ni más ni menos espacio entre
        «<code>#define</code>» y la llave
        «<code>{</code>» o «<code>}</code>».</p>
    </section>

    <section id="binary-include">
      <h2>Inclusión binaria: <a class="anchor" href="#binary-include">#binary-include</a></h2>
      <p>Inserta un fichero en forma de ristra de octetos.</p>
      <code>#include &lt;stdint.h&gt;
const uint8_t imagen
#include {images/cedro-32x32.png}
;</code>
      <code>#include &lt;stdint.h&gt;
const uint8_t imagen
[1480] = { /* cedro-32x32.png */
0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,…
0x00,0x00,0x00,0x20,0x00,0x00,0x00,…
⋮
};</code>
      <p>El nombre de fichero es relativo al fichero C incluyente.</p>
      <p>Nota: la directiva debe empezar exactamente con «<code>#include {</code>»,
        ni más ni menos espacio entre
        «<code>#include</code>» y la llave «<code>{</code>».</p>
      <h3 id="binary-include-related-work">Obras relacionadas <a class="anchor" href="#binary-include-related-work">#…-related-work</a></h3>
      <p>Esta característica es una vieja idea
        y hay varias implementaciones anteriores, por ejemplo
        <a href="https://github.com/ConorOG/xxd">xxd</a>
        (como <code>xxd -i</code>, <a href="http://manpages.ubuntu.com/manpages/bionic/man1/xxd.1.html">manual</a> en inglés)
        que usé hace muchos años y la tiene desde 1994.</p>
      <p>Más recientemente,
        la macro <a href="https://doc.rust-lang.org/std/macro.include_bytes.html"><code>include_bytes!()</code></a>
        me ha sido muy útil en mis programas en Rust.</p>
    </section>

    <footer>
      El Cedro Atlántico Azul del icono es el bonsai <a href="https://www.bonsai-nbf.org/collections#America">Fénix Plateado</a> en el <a href="https://usna.usda.gov/">Arbolario Nacional Estadounidense</a>.
    </footer>
  </body>
</html>
